--!ScriptAPI: 1.14
--!ScriptVersion: 2.2
-- Script name: logger.vsp
-- Author: Vlad Isac, R. Arjocu
-- Date: 02/2024
-- Description: use metadata and queue for sending log messages to url (e.g. http://logs6.papertrailapp.com:17732 )


--#region Global constants and enums **********

---@enum logLevel # Logging level.
logLevel = {
  Off   = "off",
  Error = "error",
  Warn  = "warn",
  Info  = "info",
  Debug = "debug",
  Trace = "trace",
  Dev   = "dev",
}

---@enum Priority # Syslog Protocol priority (RFC-5424).
Priority = {
  USER_ERROR = 11,
  USER_WARN  = 12,
  USER_DEV   = 13, --- "User notice" priority, but named "user dev" for consistency
  USER_INFO  = 14,
  USER_DEBUG = 15,

  MAIL_INFO  = 22,
}

---@enum LogType # Logging type/mode.
LogType = {
  OFFLINE = "offline",
  ONLINE  = "online",
}

--- URL where logs are shown on papertrail.
URL_PAPERTRAIL = "http://logs6.papertrailapp.com:17732"

--- Company name.
COMP_NAME = ""
--- POS name.
POS_NAME = ""

--- Switch to enable asserting logger code. SHOULD be used only for development!
ENABLE_LOGGER_ASSERTS = false
--- Switch to enable debugging logs for the logger itself. SHOULD be used sparsely!
ENABLE_LOGGER_LOGS = false

--- Interval in milliseconds, at which the script timer fires events for logging.
LOG_TIMER_INTERVAL = 320
--- Interval in milliseconds, at which a new round of uploading offline logs is started.
--- A good interval is [1; 10] minutes.<br/>
UPLOAD_ROUND_INTERVAL = 150000 -- 2.5 * 60'000 ms = 2.5 minutes = 2m30s

--- Maximum logging list/queue size before dumping its content to the logger's log file.
MAX_LOG_LIST_SIZE_BEFORE_DUMP = 150
--- Maximum log lines / message strings to send per send round (a log timer interval).<br/>
--- The maximum "log lines bandwidth" is:<br/>
---   3'600'000 ms / LOG_TIMER_INTERVAL * MAX_LOG_LIST_SEND_LINES;<br/>
--- reference value: MAX_REF_LOG_LINES_BANDWITDH = 3'600'000 / 300 * 10 = 120'000 logs/hour;<br/>
--- current value:   MAX_LOG_LINES_BANDWITDH     = 3'600'000 / 320 * 11 = 123'750 logs/hour.<br/>
---NOTE: Adjust the (current) values so that the following inequality holds true
---   MAX_LOG_LINES_BANDWITDH - MAX_REF_LOG_LINES_BANDWITDH > MAX_UPLOAD_LOG_LINES_BANDWIDTH !
MAX_LOG_LIST_SEND_LINES = 11

--- Log file name of this logger script.
LOGGER_LOG_NAME = "logger.log"
--- Backup log file name of this logger script.
LOGGER_BACKUP_LOG_NAME = "logger.1.log"

--- Default log type for uploading log files without a corresponding ".ini" file.
---NOTE: This is a per log file, not a per log line constant, and also applies for the logger!
LOG_TYPE_FOR_UPLOADING_LOGS_WITHOUT_INI = LogType.ONLINE
--- Maximum logging list/queue size allowed for uploading offline saved log lines.
MAX_LOG_LIST_SIZE_FOR_UPLOAD = 100
--- Maximum logging list/queue size allowed after an uploading round.
MAX_LOG_LIST_SIZE_AFTER_UPLOAD = 120
--- Maximum log lines to upload per upload round (if the logging list/queue size allows).
--- The maximum "upload log lines bandwidth" is:<br/>
---   360'000 ms / UPLOAD_ROUND_INTERVAL * MAX_LOG_LINES_TO_UPLOAD;<br/>
--- current value: MAX_UPLOAD_LOG_LINES_BANDWIDTH = 3'600'000 / 150'000 = 960 logs/hour.<br/>
--- Example: A 3000 lines log file is sent the fastest in 3000 / 960 = 3.125 hours = 3h7m30s.
MAX_LOG_LINES_TO_UPLOAD = 40
--- The chunk size to be uploaded from an offline log file, in an uploaded round. More
--- than this value might be read and processed.<br/>
LOG_CHUNK_SIZE_TO_UPLOAD = 2^13 -- 8 KB
--- The maximum age of offline log lines, which will be uploaded.
UPLOAD_LOG_LINE_AGE_IN_DAYS = 30
--- The maximum tries for uploading a log line / message string, practically denoting the max.
--- count an uploaded log line can fallback to file and be reuploaded. Valid range [1, 10].
MAX_LOG_LINE_UPLOAD_TRIES = 5
--- The maximum rounds for trying to delete a fully uploaded log file. A good range [2, 10].
MAX_UPLOADED_LOG_DELETION_ROUNDS = 3

--- ISO 8601 date constants.
IsoDate = {
  DATE_SEP      = "-", --- Separator between date parts.
  TIME_MARK     = "T", --- Time mark/sign between the date and time sections.
  TIME_SEP      = ":", --- Separator between the time parts and respectively time zone parts.
  TZ_UTC_MARK   = "Z", --- Time zone UTC mark/sign.
  TZ_PLUS_MARK  = "+", --- Time zone plus mark/sign.
  TZ_MINUS_MARK = "-", --- Time zone minus mark/sign.
}
IsoDate.BYTE_DATE_SEP      = IsoDate.DATE_SEP:byte(1)
IsoDate.BYTE_TIME_MARK     = IsoDate.TIME_MARK:byte(1)
IsoDate.BYTE_TIME_SEP      = IsoDate.TIME_SEP:byte(1)
IsoDate.BYTE_TZ_UTC_MARK   = IsoDate.TZ_UTC_MARK:byte(1)
IsoDate.BYTE_TZ_PLUS_MARK  = IsoDate.TZ_PLUS_MARK:byte(1)
IsoDate.BYTE_TZ_MINUS_MARK = IsoDate.TZ_MINUS_MARK:byte(1)
--ATTENTION: keep this constant and all explicit usages of its string value in sync!
--- An unknown/unrecognized date-time.
UNKNOWN_DATETIME = "D?T?"

--#endregion **********


--#region Global variables **********

--- The logging list/queue containing all current messages to be logged.
LogList = {}
--- The structured information about the current offline log file, like the file
--- handle and a file size function.
LogFile = nil

--- The socket for sending the log lines/messages online.
LogSocket = nil
--- Count the number of logging fallbacks to file.
OfflineCounter = 0

--- The structured information about the current uploading offline log file.
UploadingLogFile = {}
--- Stop watch for uploading offline saved logs.
UploadStopWatch = vpos.datetime.StopWatch()
--- Logs related settings from all scanned ".ini" files, needed for uploading offline log files.
IniSettingsForUploadingLogs = nil

--#endregion **********


--#region Helper functions **********

--- Formats the given or current date according to the ISO 8601 (long) format
--- `yyyy-mm-ddThh:mm:ss±hh:mm`. Currently, `yyyy-mm-ddThh:mm:ss` is returned
--- (only the first 19 out of the 25 characters).<br/>
--- Example of returned date: `2016-11-09T04:25:28` (the full date could be
--- `2016-11-09T04:25:28+01:00`).
---@param date vpos.datetime.DateTime? Date to be formatted; defaults to the current date if `nil`
---@return string # The formatted given or current date
local function dateISO(date)
  local date = date or vpos.datetime.DateTime() ---@diagnostic disable-line: redefined-local
  local day, month, year = date:getDate()
  local hour, minute, second = date:getTime()

  return string.format("%s-%02d-%02dT%02d:%02d:%02d",
                       tostring(year), month, day, hour, minute, second)
end

--- Decomposes the given date in ISO 8601 (long) format `yyyy-mm-ddThh:mm:ss±hh:mm` (length
--- 25).<br/>
--- NOTE: The minimum accepted ISO date is `yyyy-mm-ddThh:mm:ss` (length 19); also accepted
--- is `yyyy-mm-ddThh:mm:ssZ` (UTC length 20) and `yyyy-mm-ddThh:mm:ss±hh` (length 22).<br/>
---Raises an error if the string is not an ISO 8601 date or a date part can't be converted.
---@param isoDate string The date in ISO 8601 format
---@return table # A table with all of the ISO date parts:
---   * `year`, `month`, `day` integer
---   * `hours`, `minute`, `second` integer
---   * `timezoneHour`, `timezoneMinute` integer 
local function decomposeIsoDate(isoDate)
  assertAndOrLog(isoDate)

  -- ISO 8601: y y y y - m m - d d T h h : m m : s s ± h h : m m
  -- Position: 1       5     8     11    14    17    20    23  25

  local dateLen = string.len(isoDate)
  if dateLen < 19 then
    error("String is too short to be an ISO 8601 date or is incomplete (down to seconds required)")
  elseif dateLen > 25 then
    error("String is too long to be an ISO 8601 date")
  end
  if string.byte(isoDate, 5)  ~= IsoDate.BYTE_DATE_SEP                        or
     string.byte(isoDate, 8)  ~= IsoDate.BYTE_DATE_SEP                        or
     string.byte(isoDate, 11) ~= IsoDate.BYTE_TIME_MARK                       or
     string.byte(isoDate, 14) ~= IsoDate.BYTE_TIME_SEP                        or
     string.byte(isoDate, 17) ~= IsoDate.BYTE_TIME_SEP                        or
     (dateLen == 20 and string.byte(isoDate, 20) ~= IsoDate.BYTE_TZ_UTC_MARK) or
     (dateLen == 22 and
      (string.byte(isoDate, 20) ~= IsoDate.BYTE_TZ_PLUS_MARK or
       string.byte(isoDate, 20) ~= IsoDate.BYTE_TZ_MINUS_MARK))               or
     (dateLen == 25 and
      (string.byte(isoDate, 20) ~= IsoDate.BYTE_TZ_PLUS_MARK  or
       string.byte(isoDate, 20) ~= IsoDate.BYTE_TZ_MINUS_MARK or
       string.byte(isoDate, 23) ~= IsoDate.BYTE_TIME_SEP)) then
    error("String is not an ISO 8601 date")
  end

  local year = tonumber(string.sub(isoDate, 1, 4))
  if not year then error("Can't convert year to number") end
  local month = tonumber(string.sub(isoDate, 6, 7))
  if not month then error("Can't convert month to number") end
  local day = tonumber(string.sub(isoDate, 9, 10))
  if not day then error("Can't convert day to number") end

  local hour = tonumber(string.sub(isoDate, 12, 13))
  if not hour then error("Can't convert hour to number") end
  local minute = tonumber(string.sub(isoDate, 15, 16))
  if not minute then error("Can't convert minute to number") end
  local second = tonumber(string.sub(isoDate, 18, 19))
  if not second then error("Can't convert second to number") end

  local timezoneHour, timezoneMinute
  if dateLen == 22 then
    timezoneHour = tonumber(string.sub(isoDate, 21, 22))
    if not timezoneHour then error("Can't convert time zone hour to number") end
  else
    timezoneHour = 0
  end
  if dateLen == 25 then
    timezoneMinute = tonumber(string.sub(isoDate, 24, 25))
    if not timezoneMinute then error("Can't convert time zone minute to number") end
  else
    timezoneMinute = 0
  end

  return {
    year = year, month = month, day = day, hour = hour, minute = minute, second = second,
    timezoneHour = timezoneHour, timezoneMinute = timezoneMinute,
  }
end

--- Composes the given decomposed date to the day-month-year and hour-minute-second
--- format `dd.mm.yyyy_hh:mm:ss` (length 19). If the given decomposed date is `nil`,
--- then `UNKNOWN_DATETIME` string is returned.<br/>
--- Example of returned date: `09.11.2016_04:25:28`.
---@param decomposedDate table? The decomposed ISO date
---@return string # The formatted date, or `UNKNOWN_DATETIME` <br/>
---@see decomposeIsoDate 
local function composeDmyHmsDate(decomposedDate)
  if not decomposedDate then return UNKNOWN_DATETIME end
  return string.format("%02d.%02d.%04d_%02d:%02d:%02d",
                       decomposedDate.day, decomposedDate.month, decomposedDate.year,
                       decomposedDate.hour, decomposedDate.minute, decomposedDate.second)
end

--- Clones the object in a custom way.
--- If the object is a table and for all its table fields recursively, it does a deep
--- clone. For all non-table fields recursively, or if the object is not a table, it
--- does a shallow clone.
--- There are two aspects this function does not handle:
--- * metatables
--- * recursive tables.
---@param obj any The object to be cloned
---@return any # The cloned object
local function cloneTablesDeepOthersShallow(obj)
  if type(obj) ~= "table" then return obj end

  local res = {}
  for k, v in pairs(obj) do
    res[cloneTablesDeepOthersShallow(k)] = cloneTablesDeepOthersShallow(v)
  end
  return res
end

--- Determines if a string is nil or empty, or contains only whitespaces.
---@param str string The string
---@return boolean # `true` if the string is nil or empty or only whitespaces, otherwise `false`
local function isNilOrWhitespaceString(str)
  if not str or str:len() == 0 then return true end
  return (str:find("^%s+$")) ~= nil
end

--- Trims one newline character combination, LF (Linux) or CR-LF (Windows), from the
--- end of the given string.<br/>
--- NOTE: CR (macOS) seems not to be supported by Lua or VPOS!<br/>
--- Raises an error if the given string is `nil`. 
---@param str string The string
---@return string str The trimmed string
local function trimStringEndNewline(str)
  if not str then error("Nil string") end
  local i, _ = str:find("\r?\n$")
  if i then
    return str:sub(1, i - 1)
  else
    return str
  end
end

--- Determines if the given string is a valid constant from `LogType` enum.
---@param logTypeStr string? The given log type string
---@return boolean # `true` if valid, otherwise `false` <br/>
---@see LogType
local function isValidLogType(logTypeStr)
  if not logTypeStr then  assertAndOrLog(false, "Nil log type");  return false
  elseif logTypeStr == LogType.ONLINE or
         logTypeStr == LogType.OFFLINE then               return true
  else                  assertAndOrLog(false, "Not a log type");  return false end
end

--ATTENTION: keep this mapping function and all explicit priority usages in sync! 
local function mapMessageLevelToPriority(messageLevel)
  if not messageLevel then  assertAndOrLog(false, "Nil message level");  return Priority.USER_INFO
  elseif messageLevel == logLevel.Trace or
         messageLevel == logLevel.Debug then                             return Priority.USER_DEBUG
  elseif messageLevel == logLevel.Info then                              return Priority.USER_INFO
  elseif messageLevel == logLevel.Dev then                               return Priority.USER_DEV
  elseif messageLevel == logLevel.Warn then                              return Priority.USER_WARN
  elseif messageLevel == logLevel.Error then                             return Priority.USER_ERROR
  else             assertAndOrLog(false, "Unrecognized message level");  return Priority.USER_INFO end
end

--- Logs a developer message for the logger with the format "`devMsg`: `errMsg`".
---@param devMsg string The developer message; should always be given by the developer
---@param errMsg any The error message or number; might be `nil` only exceptionally
local function logDev(devMsg, errMsg)
  ListPushLeft({
    datetime     = dateISO(),
    scriptName   = "logger.vsp",
    url          = URL_PAPERTRAIL,
    logType      = LogType.ONLINE,
    logSize      = 300,
    priority     = Priority.USER_DEV,
    messageLevel = logLevel.Dev,
    message      = (devMsg or "") .. ": " .. (errMsg or ""),
  })
end

local logDebug
if ENABLE_LOGGER_LOGS then
  --- Logs a debug message for the logger, containing the calling function name and
  --- line and a string formatted with the given format and vararg.
  ---@param msgFormat string The message format
  ---@param ... any The vararg
  logDebug = function(msgFormat, ...)
    local info = debug.getinfo(2, "nl")
    ListPushLeft({
      datetime     = dateISO(),
      scriptName   = "logger.vsp",
      url          = URL_PAPERTRAIL,
      logType      = LogType.ONLINE,
      logSize      = 300,
      priority     = Priority.USER_DEBUG,
      messageLevel = logLevel.Debug,
      message      = string.format("%s:%d " .. msgFormat, info.name, info.currentline, ...),
    })
  end
else
  logDebug = function(msgFormat, ...) end
end

if not ENABLE_LOGGER_ASSERTS then
  assert = function(condition, message, ...) end
end

if ENABLE_LOGGER_LOGS then
  --- Asserts the given condition and/or logs a debug message for the logger on
  --- failed condition, containing the calling function name and line and the given
  --- error message.
  ---@param condition any The assertion condition
  ---@param errMsg string? The error message to be displayed and/or logged on failure
  assertAndOrLog = function(condition, errMsg)
    assert(condition, errMsg)
    if not condition then
      local info = debug.getinfo(2, "nl")
      ListPushLeft({
        datetime     = dateISO(),
        scriptName   = "logger.vsp",
        url          = URL_PAPERTRAIL,
        logType      = LogType.ONLINE,
        logSize      = 300,
        priority     = Priority.USER_DEBUG,
        messageLevel = logLevel.Debug,
        message      = string.format("%s:%d %s",
                        info.name, info.currentline, errMsg or "assertion failed"),
      })
    end
  end
else
  assertAndOrLog = function(condition, errMsg) assert(condition, errMsg) end
end

--#endregion **********


--#region Script metadata functions **********

--- Reads the queue from the script metadata, indexed by "key" key.
---@return table? # The metadata queue indexed by "key" if present, otherwise `nil`
function readMD()
  local metaTab = vpos.script.currentScript():getMetaData()
  if not metaTab or not next(metaTab) then
    return nil
  else
    return metaTab.key
  end
end

--- Writes the queue to the script metadata, indexed by the given key.
---@param q table? The queue
---@param key string? The indexing key in the metadata; defaults to "key" if `nil`
---@return boolean # `true` on success, otherwise `false`
function writeMD(q, key)
  if not q or not next(q) then return false end
  key = key or "key"
  local metaTab = {key = q}
  return vpos.script.currentScript():setMetaData(metaTab)
end

--- Clears the script metadata.
--- Practically, erases the log queue and saves this empty queue to the metadata.
function clearMD()
  eraseQueue(LogList)
  writeMD(LogList)
end

--#endregion **********


--#region Log queue functions **********

--- Gets the queue size.
---@param q table The queue
---@return number # The queue size
function queueSize(q)
  return math.abs(q.first) - math.abs(q.last) + 1
end

--- Checks if the queue is empty.
---@param q table The queue
---@return boolean # `true` if the queue is empty, otherwise `false`
function isQueueEmpty(q)
  if not q.first or not q.last then return true end
  if q.first > q.last then return true else return false end
end

--- Erases all elements from the queue.
---@param q table The queue
function eraseQueue(q)
  for i in pairs(q) do
    q[i] = nil
  end
  q.first = 0
  q.last = -1
end

--- Dumps the queue to file.
---@param q table The queue
function dumpQueue(q)
  -- dump all to file logger.log
  local f = getLogFile("logger.vsp", 500)
  local message = ""
  local size = 0
  local count = 0
  q.first = nil
  q.last = nil
  for k, v in pairs(q) do
      message = message .. v.scriptName .. " " .. v.datetime .. " " .. v.message .. "\n"
      size = size + #message
      if size > 5000 then
        f.fh:write(message)
        f.fh:flush()
        count = count + size
        message = ""
        size = 0
      end
  end
  f.fh:close()

  return count
end

--- Gets the queue saved in the script metadata if present, otherwise an empty
--- and initialized queue.
---@return table initMetaData The inital queue <br/>
---@see readMD
---@see isQueueEmpty
function getInitialQueue()
  local ok, initMetaData = pcall(readMD)
  if not ok then -- `initMetaData` is pcall's error message here
    logDev("Can't read metadata", initMetaData)
  end
  if ok and initMetaData and not isQueueEmpty(initMetaData) then
    return initMetaData
  else
    return {first = 0, last = -1}
  end
end

--- Enqueues a message(/element) to the tail of the log list/queue.
---@param message table The structured information about the log message
function ListPushLeft(message)
  if not message then return end
  local first = (LogList and LogList.first or 0) - 1
  message.datetime = message.datetime or dateISO()
  message.priority = message.priority or Priority.MAIL_INFO
  LogList.first = first
  LogList[first] = cloneTablesDeepOthersShallow(message)
  -- save the new queue to metadata
  writeMD(LogList)
end

--- Gets/Peeks the element from the head of the list/queue.
---@param q table The queue
---@return table # The head element
function ListGetRight(q)
  local last = q.last
  return q[last]
end

--- Dequeues the element from the head of the list/queue.
---@param q table The queue
function ListPopRight(q)
  local last = q.last
  q[last] = nil
  q.last = last - 1
end

--- Sends and pops the head element(/message) of the queue, and updates the
--- script metadata.
---@param q table The queue
function sendFromQueue(q)
  local ok, message = pcall(ListGetRight, q)
  assertAndOrLog(ok, message)
  message.qLast = q.last
  message.qFirst = q.first
  if ok then
    local ok, err = pcall(sendMessage, message)
    assert(ok, err)
    if ok then
      ok, err = pcall(ListPopRight, q)
      assert(ok, err)
      if ok then
        writeMD(q)
      else
        ListPushLeft({
          scriptName   = "logger.vsp",
          url          = URL_PAPERTRAIL,
          logType      = LogType.ONLINE,
          logSize      = 300,
          priority     = Priority.USER_ERROR,
          messageLevel = logLevel.Error,
          message      = err,
        })
      end
    else
      ListPushLeft({
        scriptName   = "logger.vsp",
        url          = URL_PAPERTRAIL,
        logType      = LogType.ONLINE,
        logSize      = 300,
        priority     = Priority.USER_ERROR,
        messageLevel = logLevel.Error,
        message      = err,
      })
    end
  end
end

--- Manages the queue.
---@param q table The queue
function handleQueue(q)
  if not isQueueEmpty(q) then
    local qSize = queueSize(q)
    --showStatus("Q:"..tostring(qSize))
    if qSize > MAX_LOG_LIST_SIZE_BEFORE_DUMP then
      local ok, resp = pcall(dumpQueue, q)
      assertAndOrLog(ok, resp)
      eraseQueue(q) -- empty the log queue

      ListPushLeft({
        scriptName   = "logger.vsp",
        url          = URL_PAPERTRAIL,
        logType      = LogType.ONLINE,
        logSize      = 300,
        priority     = Priority.USER_ERROR,
        messageLevel = logLevel.Error,
        message      = "QUEUE WAS ERASED:" .. tostring(resp)
      })
      local resp2
      ok, resp2 = pcall(writeMD, q)
      assertAndOrLog(ok, resp2)
    else
      local limit
      if qSize < MAX_LOG_LIST_SEND_LINES then limit = qSize else limit = MAX_LOG_LIST_SEND_LINES end
      for i = 1, limit do
        local ok, resp = pcall(sendFromQueue, q)
        assert(ok, resp)
        if not ok then
          ListPushLeft({
            scriptName   = "logger.vsp",
            url          = URL_PAPERTRAIL,
            logType      = LogType.ONLINE,
            logSize      = 300,
            priority     = Priority.USER_ERROR,
            messageLevel = logLevel.Error,
            message      = resp
          })
        end
      end
    end
  end
end

--#endregion **********


--#region File functions **********

--- Gets the file extension from the file name (without a path).
---@param fileName string? The file name (without a path)
---@return string? # The file extension on successful extraction, otherwise `nil`
local function get_file_extension_from_name(fileName)
  if not fileName then return nil end

  local i, _ = fileName:find("%.%w*$")
  return ((not i or (i == 1)) and "") or fileName:sub(i + 1)
end

--- Gets the base file name, namely the file name without the extension, from the file name
--- (without a path).
---@param fileName string? The file name (without a path)
---@return string? # The base file name on successful extraction, otherwise `nil`
local function get_base_file_name_from_name(fileName)
  if not fileName then return nil end

  local i, _ = fileName:find("%.%w*$")
  return ((not i or (i == 1)) and fileName) or fileName:sub(1, i - 1)
end

local function removeLogBackupSuffixFromBaseFileName(baseFileName)
  if not baseFileName then return nil end

  local i, _ = baseFileName:find("%.1$")
  return ((not i or (i == 1)) and baseFileName) or baseFileName:sub(1, i - 1)
end

local function getBaseFileNameWithoutLogBackupSuffixFromName(fileName)
  if not fileName then return nil end

  local baseFileName = get_base_file_name_from_name(fileName)
  return removeLogBackupSuffixFromBaseFileName(baseFileName)
end

--- Constants defining which file hosts are allowed.
--NOTE: defining this here, because it's exclusively used in the next fun. 
AllowedFileHosts = {["VPOS"] = true, ["FILE"] = true, ["MEDIAFILE"] = false}

--- Checks for the existance of the file.
---@param fn string The file name/path to be checked
---@param host string? The file host; defaults to "VPOS" if `nil` and a host can't be extracted from `fn`
---@return boolean `true` if the file exists, otherwise `false` <br/>
---@see AllowedFileHosts
local function file_exists(fn, host)
  if not fn then return false end

  local i, j = string.find(fn, ":", 1, true)
  local fileHost
  if i then
    fileHost = fn:sub(1, j-1)
    fn = fn:gsub("VPOS:", "")
    fn = fn:gsub("FILE:", "")
  end

  host = host or fileHost or "VPOS"
  if not AllowedFileHosts[host] then return false end

  local scripts = vpos.file.getFileList(host)
  for _, s in pairs(scripts) do
    if fn == s then
      return true
    end
  end
  return false
end

--- Moves/Renames a file.
---@param fn1 string The source file name/path
---@param fn2 string The destination file name/path
---@param overwrite boolean Flag to overwrite an existing destination file
---@return boolean # `true` if moving/renaming succeeded, otherwise `false`
---@return string|number? # `nil` on success, otherwise an error message or number
local function file_rename(fn1, fn2, overwrite)
  if not file_exists(fn1) then
    return false, string.format("Source file %s is missing!", fn1 or "")
  end
  if file_exists(fn2) and not overwrite then
    return false, string.format("Destination file %s already exists!", fn2)
  end

  local ok, err = vpos.renameFile(fn1, fn2)
  -- if the error is DestinationFileExists and we have to overwrite
  if not ok and err == 1 and overwrite then
    ok, err = vpos.file.delete(fn2)
    ok, err = vpos.renameFile(fn1, fn2)
    return ok, err
  end
  return ok, err
end

--- Delete the given log file.
---@param filePath string The log file path
---@param logErrors boolean Flag for logging any encountered error
---@return boolean ok `true` if the file deletion succeeded, otherwise `false`
---@return number errNo A `vpos.file.Error` number
local function deleteLogFile(filePath, logErrors)
  assertAndOrLog(filePath)
  local ok, errNo = vpos.file.delete(filePath)
  if logErrors and not ok then logDev("Can't delete file " .. filePath, errNo) end
  return ok, errNo
end

--- Creates or opens a log file having the script's base name and extension ".log".
---@param scriptName string The script name
---@param logSizeInKB number? The maximum log size in kilobytes before creating a new file
---@return table # A table containing:
--- * `fh` userdata/file*: the log file handler
--- * `size` function: gets the current log size
--- * `scriptBaseName` string: the script base name
function getLogFile(scriptName, logSizeInKB)
  local fileSize = logSizeInKB or 300
  local scriptBaseName = get_base_file_name_from_name(scriptName)
  local fileName = tostring(scriptBaseName or "log") .. ".log"
  local filePath = "VPOS:" .. fileName

  local logSize = function()
                    local logFileAsScript = vpos.script.Script(filePath)
                    if logFileAsScript then
                      return tonumber(logFileAsScript:getSize())/1000 or 0
                    else
                      return 0
                    end
                  end

  local curSize = logSize()
  local fh, errMsg
  if curSize < fileSize then
    fh, errMsg = io.open(filePath, "a+")
    assert(fh, errMsg)
    if not fh then logDev("Can't open file " .. fileName .. " in A+ mode", errMsg) end
  end
   -- roll over the log file
  if not fh then -- an `or curSize >= fileSize` condition is superfluos
    -- rename the log file
    local backupFileName = fileName:sub(1, -5) .. ".1.log"
    local backupFilePath = "VPOS:" .. backupFileName
    local ok, frOk, frErr = pcall(file_rename, filePath, backupFilePath, true)
    if not ok then -- the `file_rename()` call failed
      if curSize >= fileSize then -- `frOk` is pcall's error message here
        logDev("Can't rename file " .. fileName .. " to " .. backupFilePath, frOk)
      end
    else -- the `file_rename()` call succeeded
      if not frOk then -- the log file wasn't renamed
        if curSize >= fileSize then
          logDev("Can't rename file " .. fileName .. " to " .. backupFilePath, frErr)
        end
        -- delete the log file and reset the uploading log file
        if (deleteLogFile(filePath, true)) and UploadingLogFile.fileName == fileName then
          UploadingLogFile = {}
        end
      else -- the log file was successfully renamed
        if UploadingLogFile.fileName == fileName then -- update file name of uploading log file
          UploadingLogFile.fileName = backupFileName
        elseif UploadingLogFile.fileName == backupFileName then -- reset the uploading log file
          UploadingLogFile = {}
        end
      end
    end

    -- write a new log file
    fh, errMsg = io.open(filePath, "w")
    if not fh then
      logDev("Can't open file " .. fileName .. " in W mode", errMsg)
    elseif UploadingLogFile.fileName == fileName then -- reset the uploading log file
      UploadingLogFile = {}
    end
  end

  return {fh = fh, size = logSize, scriptBaseName = scriptBaseName}
end

--#endregion **********


--#region Log message functions **********

--- Decomposes/Unformats an offline message string/line into its parts, owning to the
--- logger script.<br/>
--- Raises an error if the message can't be decomposed or a message part can't be converted.
---@param str string The message string/line
---@return table # A table with all of the message string parts:
---  * `scriptName` string: the script name, which originally logged this message 
---  * `sendingIsoDate` string: should be in ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`
---  * `messageLevel` string: defaulted as `logLevel.Info`
---  * `messageBody` string: the actual message content
local function decomposeLoggerOfflineMessageString(str)
  assertAndOrLog(str)

  local scriptName, sendingIsoDate, messageBody = str:match("^(%S+)%s+(%S+)%s+(.-)\r?\n$")
  if not scriptName then error("Can't decompose logger offline message string") end

  return {
    scriptName = scriptName, sendingIsoDate = sendingIsoDate, messageLevel = logLevel.Info,
    messageBody = messageBody,
  }
end

--- Decomposes/Unformats an offline message string/line into its parts.<br/>
--- Raises an error if a message part can't be determined or converted.
---@param str string The message string/line
---@return table # A table with all of the message string parts:
---  * `sendingIsoDate` string: should be in ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`
---  * `messageLevel` string: the log level
---  * `qFirst`, `qLast` integer: the original queue boundary indexes
---  * `messageBody` string: the actual message content
local function decomposeOfflineMessageString(str)
  assertAndOrLog(str)

  local sendingIsoDate, messageLevel, qFirstStr, qLastStr, messageBody =
    str:match("^(%S+) %[(%S+)%] >> ([+-]?%d+):([+-]?%d+) (.-)\r?\n$")
  if not sendingIsoDate then error("Can't decompose offline message string") end

  local qFirst = tonumber(qFirstStr)
  if not qFirst then error("Can't convert queue first index to number") end
  local qLast = tonumber(qLastStr)
  if not qLast then error("Can't convert queue last index to number") end

  return {
    sendingIsoDate = sendingIsoDate, messageLevel = messageLevel,
    qFirst = qFirst, qLast = qLast, messageBody = messageBody,
  }
end

--- Formats the message by adding information about the script and POS terminal.
--- @param message table Message containing the needed information
--- @param fallback boolean `true` if called due to fallback
--- @return string outStr Log message to send
function formatMessage(message, fallback)
  local outStr = ""

  if message.logType == LogType.ONLINE and not fallback then
    local scriptVersion = vpos.tables.Table(806):getData(message.scriptName, 15)
    scriptVersion = tostring((scriptVersion ~= nil and scriptVersion ~= "" and scriptVersion) or 0)
    local scriptData = string.format("%s_v:%s", message.scriptName, scriptVersion)
    local trace = (message.messageLevel == logLevel.Trace and "[trace] ") or ""

    outStr = "<" .. message.priority .. ">1 " .. message.datetime .. " " .. COMP_NAME .. POS_NAME ..
             " " .. scriptData .. " - - - " .. trace ..
             math.abs(message.qFirst) .. ":" .. math.abs(message.qLast) .. " " .. message.message .. "\n"
  else
    outStr = message.datetime .. " [" .. message.messageLevel .. "] >> " ..
             math.abs(message.qFirst) .. ":" .. math.abs(message.qLast) .. " " .. message.message .. "\n"
  end

  return outStr
end

local function createOrRecreateLogSocket(url)
  -- retry to create the socket only after several logs were locally written
  if (not LogSocket and (OfflineCounter == 0 or OfflineCounter >= 9)) or OfflineCounter >= 9 then
    local logUrl = url:gsub("http://", "")
    local address, port = logUrl:match("(.-):(%d+)")
    assertAndOrLog(address and port)
    LogSocket = vpos.communication.Socket(address, port, 3000)
    OfflineCounter = 0
  end
end

--- Sends the message to be logged using sockets over the internet (online mode). If
--- this fails or is explicitly requested, writes the message to a file (offline mode).
---@param message table Message table containing the information to be logged
function sendMessage(message)
  local ok, outStr = pcall(formatMessage, message)
  assert(ok, outStr)
  if not ok then
    outStr = "<11>1 " .. dateISO() .. " " .. COMP_NAME .. POS_NAME ..
             " logger.vsp - - - ________PCALL error:" .. tostring(outStr) .. "\n"
  end

  local fallbackToFile = false
  if message.logType == LogType.ONLINE and message.url then
    createOrRecreateLogSocket(message.url)

    local sent = LogSocket and LogSocket:write(outStr)
    if not sent then
      fallbackToFile = true
      OfflineCounter = OfflineCounter + 1
      ok, outStr = pcall(formatMessage, message, true)
      assert(ok, outStr)
    end
  else
    fallbackToFile = true
  end

  if fallbackToFile then
    local scriptBaseName = get_base_file_name_from_name(message.scriptName)
    if not LogFile or LogFile.size() >= message.logSize or
       scriptBaseName ~= LogFile.scriptBaseName then
      if LogFile then LogFile.fh:close() end
      LogFile = getLogFile(message.scriptName, message.logSize)
      logDebug("Got log file %s with current size %.2f KB", LogFile.scriptBaseName, LogFile.size())
    end
    LogFile.fh:write(outStr)
    LogFile.fh:flush()
  end
end

--#endregion **********


--#region Upload offline logs functions **********

local function isUploadRound()
  local split = UploadStopWatch:split()
  if split < UPLOAD_ROUND_INTERVAL then
     return false
  else
     return true
  end
end

local function resetUploadRound()
  UploadStopWatch:reset()
  UploadStopWatch:start()
end

local function determineMaxLogLinesForUploadRound()
  local logListSize = queueSize(LogList)
  if logListSize > MAX_LOG_LIST_SIZE_FOR_UPLOAD then return 0 end

  local uploadLogLines = MAX_LOG_LIST_SIZE_AFTER_UPLOAD - logListSize
  if uploadLogLines < MAX_LOG_LINES_TO_UPLOAD then
    return uploadLogLines
  else
    return MAX_LOG_LINES_TO_UPLOAD
  end
end

local function isLoggerConnectedOnline()
  createOrRecreateLogSocket(URL_PAPERTRAIL)
  if not LogSocket then return false end
  return LogSocket:isOpen() and LogSocket:isConnected()
end

local function readIniSettingsForUploadingOfflineLogs()
  if IniSettingsForUploadingLogs then return end

  local fileList = vpos.file.getFileList("VPOS")
  IniSettingsForUploadingLogs = {}

  for _, fileName in pairs(fileList) do
    if get_file_extension_from_name(fileName) == "ini" then
      local filePath = "VPOS:" .. fileName
      local initTab = vpos.utils.readIniFromFile(filePath)
      if initTab and type(initTab) == "table" and
         initTab.LOGS and type(initTab.LOGS) == "table" then
        local logType = string.lower(tostring(initTab.LOGS.LOG_TYPE))
        if not isValidLogType(logType) then
          logDev("Can't store " .. fileName .. " setting", logType .. " is not a valid log type")
        else
          local baseFileName = get_base_file_name_from_name(fileName)
          if not baseFileName then
            logDev("Can't store " .. fileName .. " setting", "Can't get base file name")
          else
            IniSettingsForUploadingLogs[baseFileName] = {LOG_TYPE = logType}
          end
        end
      end
    end
  end
end

local function updateUploadingLogFileWhileDeletingEmptyLogFiles()
  local fileList = vpos.file.getFileList("VPOS")

  -- update the file size and deletion round of the existing uploading log file if not empty,
  -- in which case it'll be deleted
  if UploadingLogFile.fileName then
    assertAndOrLog(UploadingLogFile.fileSize)
    for _, fileName in pairs(fileList) do
      if fileName == UploadingLogFile.fileName then
        local filePath = "VPOS:" .. fileName
        local logFileAsScript = vpos.script.Script(filePath)
        if not logFileAsScript then break end
        local logSize = logFileAsScript:getSize()
        if logSize <= 0 then
          deleteLogFile(filePath, true)
          break
        else
          if logSize > UploadingLogFile.fileSize then UploadingLogFile.deletionRound = 0 end
          UploadingLogFile.fileSize = logSize
          return
        end
      end
    end
  end
  -- the previous uploading log file doesn't exist anymore
  UploadingLogFile = {}

  -- add a new uploading log file, while deleting encountered empty log files
  for _, fileName in pairs(fileList) do
    if get_file_extension_from_name(fileName) == "log" then
      local baseFileName = getBaseFileNameWithoutLogBackupSuffixFromName(fileName)
      local logType = (IniSettingsForUploadingLogs[baseFileName] and
                       IniSettingsForUploadingLogs[baseFileName].LOG_TYPE) or
                      LOG_TYPE_FOR_UPLOADING_LOGS_WITHOUT_INI
      if logType == LogType.ONLINE then
        local filePath = "VPOS:" .. fileName
        local logFileAsScript = vpos.script.Script(filePath)
        if logFileAsScript then
          local logSize = logFileAsScript:getSize()
          if logSize <= 0 then
            deleteLogFile(filePath, true)
          else
            UploadingLogFile = {
              fileName         = fileName,
              fileSize         = logSize,
              readOffset       = 0,
              deletionRound    = 0,
              lastScriptName   = baseFileName .. ".log",
              lastIsoDate      = dateISO(),
              lastMessageLevel = logLevel.Info,
            }
            return
          end
        end
      end
    end
  end
end

local function decomposeUploadingLogFileLine(line)
  local fileName = UploadingLogFile.fileName
  assertAndOrLog(fileName)

  if fileName == LOGGER_LOG_NAME or fileName == LOGGER_BACKUP_LOG_NAME then
    return decomposeLoggerOfflineMessageString(line)
  else
    return decomposeOfflineMessageString(line)
  end
end

local function updateLastScriptNameAndMessageLevelOfUploadingLogFile(decomposedMsg)
  if not isNilOrWhitespaceString(decomposedMsg.scriptName) then
    UploadingLogFile.lastScriptName = decomposedMsg.scriptName
  end
  if not isNilOrWhitespaceString(decomposedMsg.messageLevel) then
    UploadingLogFile.lastMessageLevel = decomposedMsg.messageLevel
  end
end

local function resetLastScriptNameAndMessageLevelOfUploadingLogFile()
  local fileName = UploadingLogFile.fileName
  assertAndOrLog(fileName)

  UploadingLogFile.lastScriptName   = getBaseFileNameWithoutLogBackupSuffixFromName(fileName) .. ".log"
  UploadingLogFile.lastMessageLevel = logLevel.Info
end

--- Changes the last message level of the uploading log file from trace to debug for
--- undecomposable log lines, because these are in all likelyhood log lines after the
--- first line of the logical message (broken on multiple lines); the first log line
--- already marks the logical message as a trace. This is the displayed way also for
--- online logs.
local function changeLastMessageLevelOfUploadingLogFileFromTraceToDebug()
  assertAndOrLog(UploadingLogFile.lastMessageLevel)
  if UploadingLogFile.lastMessageLevel == logLevel.Trace then
    UploadingLogFile.lastMessageLevel = logLevel.Debug
  end
end

--- Determines if a log file line / message string is recent enough for uploading.
---@param decomposedDate table The decomposed sending ISO date of a log file line / message string
---@return boolean # `true` if the log file line is recent enough for uploading, otherwise `false`
local function isRecentLogFileLine(decomposedDate)
  assertAndOrLog(decomposedDate)

  local date = vpos.datetime.DateTime()

  -- get the reference/minimum date, as Unix time
  date:add(vpos.datetime.DateField.Day, -UPLOAD_LOG_LINE_AGE_IN_DAYS);
  local refUnixTime = date:getUnixTime()

  -- set the log line date
  date:setDate(decomposedDate.day, decomposedDate.month, decomposedDate.year)
  date:setTime(decomposedDate.hour, decomposedDate.minute, decomposedDate.second)

  -- compare the dates
  return date:getUnixTime() >= refUnixTime
end

--- Checks if a log file line / message string is recent enough for uploading, by
--- decomposing the given ISO date and if ok, determining the recency and updating the
--- last date for the uploading log file.
---@param isoDate any The sending ISO date of a log file line / message string
---@return boolean # `true` if the log file line is recent enough for uploading, otherwise `false`
---@return table? decomposedDate The decomposed ISO date if the decomposition succeeded, otherwise `nil` <br/>
---@see decomposeIsoDate 
local function checkLineRecencyThenUpdateLastDateOfUploadingLogFile(isoDate)
  local ok, decomposedDate = pcall(decomposeIsoDate, isoDate)
  if not ok then
    -- `decomposedDate` is pcall's error message here
    logDev("Can't decompose " .. isoDate .. " as ISO date", decomposedDate)
    -- upon errors consider the log line as being recent
    return true, nil
  end

  -- update last ISO date of the current uploading log file
  UploadingLogFile.lastIsoDate = isoDate

  return isRecentLogFileLine(decomposedDate), decomposedDate
end

--- First determines if a log message body starts with a date in `dd.mm.yyyy_hh:mm:ss` format
--- (denoting the generated at timestamp) and an upload try number. If not, then it prepends
--- them and the corresponding log line can be uploaded. Else (if the message body contains
--- these 2 elements), the log line can be uploaded if the max. upload tries hasn't been
--- reached, in which case the upload try number is updated.<br/>
--- If the given `decomposedDate` is `nil`, then `UNKNOWN_DATETIME` string is prepended to
--- a log line not containing the 2 elements.
---@param msgBody string The log message body
---@param decomposedDate table? The decomposed ISO date, denoting the log line's generated at timestamp
---@return boolean # `true` if the log file line can be uploaded, otherwise `false`
---@return string msgBody The log message body with the date and upload try number prepended or updated <br/>
---@see decomposeIsoDate 
local function checkDateAndUploadTryThenPrependOrUpdateThemInLogMessageBody(msgBody, decomposedDate)
  assertAndOrLog(msgBody)
  local i, uploadTryChar

  _, _, i, uploadTryChar   = msgBody:find("^%d%d%.%d%d%.%d%d%d%d_%d%d:%d%d:%d%d|U()(%d) ")
  if not uploadTryChar then
    _, _, i, uploadTryChar = msgBody:find("^D%?T%?|U()(%d) ")
  end
  if not uploadTryChar then -- 0th upload try
    msgBody = string.format("%s|U0 %s", composeDmyHmsDate(decomposedDate), msgBody)
    return true, msgBody
  else -- we already tried to upload this line at least once
    local uploadTry = tonumber(uploadTryChar) + 1
    if uploadTry < MAX_LOG_LINE_UPLOAD_TRIES then
      msgBody = string.format("%s|U%d %s", msgBody:sub(1, i - 3), uploadTry, msgBody:sub(i + 2))
      return true, msgBody
    else
      return false, msgBody
    end
  end
end

local function uploadLogFileLine(line)
  assertAndOrLog(line and UploadingLogFile.lastScriptName and UploadingLogFile.lastMessageLevel)
  local msgBody, decomposedDate

  local ok, decomposedMsg = pcall(decomposeUploadingLogFileLine, line)
  if not ok then -- there can be multi-line messages, messages with unknown format etc.
    msgBody = trimStringEndNewline(line)

    --NOTE: the log line failed to decompose, so first check if it contains only whitespaces
    if isNilOrWhitespaceString(msgBody) then
      resetLastScriptNameAndMessageLevelOfUploadingLogFile()
      return false
    else
      changeLastMessageLevelOfUploadingLogFileFromTraceToDebug()
    end
    ok, decomposedDate = checkLineRecencyThenUpdateLastDateOfUploadingLogFile(UploadingLogFile.lastIsoDate)
    if not ok then return false end

    ok, msgBody = checkDateAndUploadTryThenPrependOrUpdateThemInLogMessageBody(msgBody, decomposedDate)
    if not ok then return false end

    ListPushLeft({
      datetime     = UploadingLogFile.lastIsoDate,
      scriptName   = UploadingLogFile.lastScriptName,
      url          = URL_PAPERTRAIL,
      logType      = LogType.ONLINE,
      logSize      = 300,
      priority     = mapMessageLevelToPriority(UploadingLogFile.lastMessageLevel),
      messageLevel = UploadingLogFile.lastMessageLevel,
      message      = msgBody,
    })
  else
    msgBody = decomposedMsg.messageBody

    --NOTE: the log line succeeded to decompose, so first update the last XYZ fields of the
    -- uploading log file and then check if the line contains only whitespaces
    updateLastScriptNameAndMessageLevelOfUploadingLogFile(decomposedMsg)
    ok, decomposedDate = checkLineRecencyThenUpdateLastDateOfUploadingLogFile(decomposedMsg.sendingIsoDate)
    if not ok then return false end
    if isNilOrWhitespaceString(msgBody) then return false end

    ok, msgBody = checkDateAndUploadTryThenPrependOrUpdateThemInLogMessageBody(msgBody, decomposedDate)
    if not ok then return false end

    --NOTE: we handle differently the date vs. script name in the 2 code branches, because
    -- the first is present in offline log lines of both the logger and other log files,
    -- while the latter is present only in the logger's own log lines
    ListPushLeft({
      datetime     = decomposedMsg.sendingIsoDate,
      scriptName   = UploadingLogFile.lastScriptName,
      url          = URL_PAPERTRAIL,
      logType      = LogType.ONLINE,
      logSize      = 300,
      priority     = mapMessageLevelToPriority(decomposedMsg.messageLevel),
      messageLevel = decomposedMsg.messageLevel,
      message      = msgBody,
    })
  end
  return true
end

local function uploadChunkOfLogFileLines(maxUploadLogLines)
  local fileName = UploadingLogFile.fileName
  assertAndOrLog(fileName)

  local uploadedLineCount = 0
  local uploadedSize = 0
  local processedSize = 0
  logDebug("Trying to upload %s @ %d", fileName, UploadingLogFile.readOffset)

  local fileHandle, err = io.open("VPOS:" .. fileName, "r")
  if not fileHandle then
    logDev("Can't open file " .. fileName .. " in R mode", err)
    return processedSize
  end

  _, err = fileHandle:seek("set", UploadingLogFile.readOffset)
  if err then
    logDev("Can't seek in file " .. fileName .. " @ " .. UploadingLogFile.readOffset, err)
    return processedSize
  end

  while uploadedLineCount < maxUploadLogLines and uploadedSize < LOG_CHUNK_SIZE_TO_UPLOAD do
    local line = fileHandle:read("L")
    if not line then break end

    local lineLen = string.len(line)
    processedSize = processedSize + lineLen

    if uploadLogFileLine(line) then
      uploadedLineCount = uploadedLineCount + 1
      uploadedSize = uploadedSize + lineLen
    end
  end

  logDebug("Processed size %d B, uploaded size %d B & lines %d",
           processedSize, uploadedSize, uploadedLineCount)
  fileHandle:close()
  return processedSize
end

local function updateReadOffsetOfUploadingLogFile(processedSize)
  assertAndOrLog(UploadingLogFile.readOffset)
  UploadingLogFile.readOffset = UploadingLogFile.readOffset + processedSize
end

local function deleteFullyProcessedLogFileAndUploadingLogFile()
  assertAndOrLog(UploadingLogFile.fileName and UploadingLogFile.readOffset and
                 UploadingLogFile.fileSize and UploadingLogFile.deletionRound)
  if UploadingLogFile.readOffset >= UploadingLogFile.fileSize then
    local fileName = UploadingLogFile.fileName
    local filePath = "VPOS:" .. fileName
    local ok, errNo = false, nil
    for _ = 0, 2 do
      ok, errNo = deleteLogFile(filePath, false)
      if ok then break end
    end
    if not ok then
      local round = UploadingLogFile.deletionRound + 1
      if round < MAX_UPLOADED_LOG_DELETION_ROUNDS then
        logDev(string.format("Can't delete file %s (3 tries, round %d)", fileName, round), errNo)
        UploadingLogFile.deletionRound = round
      else
        logDev(string.format("Can't delete file %s (3 tries, round %d), aborting", fileName, round), errNo)
        UploadingLogFile = {}
      end
    else
      UploadingLogFile = {}
    end
  end
end

function uploadOfflineLogs()
  --TODO add: offline setting check
  if not isUploadRound() then return end

  local maxUploadLogLines = determineMaxLogLinesForUploadRound()
  if maxUploadLogLines > 0 and isLoggerConnectedOnline() then
    readIniSettingsForUploadingOfflineLogs()
    updateUploadingLogFileWhileDeletingEmptyLogFiles()
    if UploadingLogFile.fileName then
      local processedSize = uploadChunkOfLogFileLines(maxUploadLogLines)
      updateReadOffsetOfUploadingLogFile(processedSize)
      deleteFullyProcessedLogFileAndUploadingLogFile()
    end
  end

  resetUploadRound()
end

--#endregion **********


--#region Timer functions **********

--- Timer function for periodically logging the real-time and offline logs.
function onLogTimer()
  local ok, err = pcall(uploadOfflineLogs)
  if not ok then logDev("Error while uploading offline logs", err) end
  ok, err = pcall(handleQueue, LogList)
  if not ok then logDev("Error while handling log queue", err) end
end

--#endregion **********


--#region Initialization functions **********

local function initSettings()
    -- format the company name
    COMP_NAME = string.lower(vpos.systeminfo.Company():getName())
    COMP_NAME = COMP_NAME:gsub("sc", ""):gsub(" ", "")
    COMP_NAME = COMP_NAME:sub(1, 4) .. "_"
    POS_NAME = tostring(vpos.getSystemInfo(vpos.SystemInfo.ECRId):gsub(" ", ""))
end

local function initLogList()
  local ok
  ok, LogList = pcall(getInitialQueue)
  assert(ok, LogList)
  if not ok then
    ok, LogList = pcall(getInitialQueue)
    if not ok then -- `LogList` is pcall's error message here
      logDev("Can't get initial log queue", LogList)
      LogList = {first = 0, last = -1}
    end
  end
end

local function initTimers()
  vpos.events.registerTimerFunction("onLogTimer", LOG_TIMER_INTERVAL)
  UploadStopWatch:start()
end

--#endregion **********


--#region MAIN **********

initSettings()
initLogList()

vpos.script.registerAsInterScript()

initTimers()

---@entrypoint ClearMetadata
vpos.events.registerEntryPointFunction(99, "clearMD")

--#endregion **********
