--!ScriptAPI: 1.14
--!ScriptVersion: 1.8
-- Script name: logger.vsp
-- Author: Vlad Isac
-- Date: 03/2020
-- Description: use metadata and queue for sending log messages to url (e.g. http://logs6.papertrailapp.com:17732 )


--*************************************************************
--- Global settings (read-only initialized variables) and constants
-- @section Global settings and constants

---@enum logLevel
local logLevel = {
  Off   = "off",
  Error = "error",
  Warn  = "warn",
  Info  = "info",
  Debug = "debug",
  Trace = "trace",
  Dev   = "dev"
}

---URL where logs are shown on papertrail
URL_PAPERTRAIL = "http://logs6.papertrailapp.com:17732"

--- Company name
COMP_NAME = ""
--- POS name
POS_NAME = ""

--- Interval in milliseconds, at which the script timer fires events for logging.
LOG_TIMER_INTERVAL = 300
--- Interval in milliseconds, at which a new round of uploading offline logs is started.
UPLOAD_ROUND_INTERVAL = 300000 -- 5 * 60 * 1000 [ms] = 5 [minutes]

--- The chunk size to be uploaded from an offline log file, in an uploaded round. More
--- than this value might be read and processed.
LOG_CHUNK_SIZE_TO_UPLOAD = 2^14 -- 16 KB
--- The max. age of oflline log lines, which will be uploaded.
UPLOAD_LOG_LINE_AGE_IN_DAYS = 30

--- ISO 8601 date constants
ISODATE = {
  DATE_SEP      = "-", --- separator between date parts
  TIME_MARK     = "T", --- time mark/sign between the date and time sections
  TIME_SEP      = ":", --- separator between the time parts and respectively time zone parts
  TZ_UTC_MARK   = "Z", --- time zone UTC mark/sign
  TZ_PLUS_MARK  = "+", --- time zone minus mark/sign
  TZ_MINUS_MARK = "-", --- time zone UTC mark/sign

  BYTE_DATE_SEP      = ISODATE.DATE_SEP:byte(1),
  BYTE_TIME_MARK     = ISODATE.TIME_MARK:byte(1),
  BYTE_TIME_SEP      = ISODATE.TIME_SEP:byte(1),
  BYTE_TZ_UTC_MARK   = ISODATE.TZ_UTC_MARK:byte(1),
  BYTE_TZ_PLUS_MARK  = ISODATE.TZ_PLUS_MARK:byte(1),
  BYTE_TZ_MINUS_MARK = ISODATE.TZ_MINUS_MARK:byte(1),
}


--*************************************************************
--- Global variables
-- @section Global variables

assert = function(...) end

--- The logging list/queue containing all current messages to be logged.
logList = {}

--- Count the number of logging fallbacks to file.
-- @global offlineCounter
offlineCounter = 0

---Table containing information on offline saved logs, for uploading them.
LogFileList = {}
---Stop watch for uploading offline saved logs.
UploadStopWatch = vpos.datetime.StopWatch()


--*************************************************************
--- Helper functions
-- @section Helper functions

---Formats the given or current date according to the ISO 8601 format
---`yyyy-mm-ddThh:mm:ss±hh:mm`. Currently, `yyyy-mm-ddThh:mm:ss` is returned
---(only the first 19 out of the 25 characters).<br/>
---Example of returned date: `2016-11-09T04:25:28` (the full date could be
---`2016-11-09T04:25:28+01:00`).
---@param date? vpos.datetime.DateTime? Date to be formatted; if `nil`, the current date is used
---@return string # Date formatted as per ISO 8601 format.
local function dateISO(date)
  local date = date or vpos.datetime.DateTime() ---@diagnostic disable-line: redefined-local
  local day, month, year = date:getDate()
  local hour, minute, second = date:getTime()

  return tostring(year) .. "-" .. string.format("%02d", month) .. "-" .. string.format("%02d", day) .. "T" ..
         string.format("%02d", hour) .. ":" .. string.format("%02d", minute) .. ":" .. string.format("%02d", second)
--  return string.format("%s-%02d-%02dT%02d:%02d:%02d",
--                       tostring(year), month, day, hour, minute, second)
end

---Decomposes the given date in ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`.
---NOTE that the minimum accepted ISO date is `yyyy-mm-ddThh:mm:ss` (length 19).<br/>
---Raises an error if the string is not an ISO 8601 date or a date part can't be converted.
---@param isoDate string The date in ISO 8601 format.
---@return table # A table with all of the ISO date parts:
---   * `year`, `month`, `day` integer
---   * `hours`, `minute`, `second` integer
---   * `timezoneHour`, `timezoneMinute` integer 
local function decomposeISODate(isoDate)
  assert(isoDate)

  -- ISO 8601: y y y y - m m - d d T h h : m m : s s ± h h : m m
  -- Position: 0       5     8     11    14    17    20    23  25

  local dateLen = string.len(isoDate)
  if dateLen < 19 then
    error("String is too short to be an ISO 8601 date or is incomplete (down to seconds required)")
  end
  if string.byte(isoDate, 5)  ~= ISODATE.BYTE_DATE_SEP          or
     string.byte(isoDate, 8)  ~= ISODATE.BYTE_DATE_SEP          or
     string.byte(isoDate, 11) ~= ISODATE.BYTE_TIME_MARK         or
     string.byte(isoDate, 14) ~= ISODATE.BYTE_TIME_SEP          or
     string.byte(isoDate, 17) ~= ISODATE.BYTE_TIME_SEP          or
     (dateLen >= 22 and
      (string.byte(isoDate, 20) ~= ISODATE.BYTE_TZ_UTC_MARK  or
       string.byte(isoDate, 20) ~= ISODATE.BYTE_TZ_PLUS_MARK or
       string.byte(isoDate, 20) ~= ISODATE.BYTE_TZ_MINUS_MARK)) or
     (dateLen >= 25 and string.byte(isoDate, 23) ~= ISODATE.BYTE_TIME_SEP) then
    error("String is not an ISO 8601 date")
  end

  local year = tonumber(string.sub(isoDate, 1, 4))
  if not year then error("Can't convert year to number") end
  local month = tonumber(string.sub(isoDate, 6, 7))
  if not month then error("Can't convert month to number") end
  local day = tonumber(string.sub(isoDate, 9, 10))
  if not day then error("Can't convert day to number") end

  local hours = tonumber(string.sub(isoDate, 12, 13))
  if not hours then error("Can't convert hour to number") end
  local minute = tonumber(string.sub(isoDate, 15, 16))
  if not minute then error("Can't convert minute to number") end
  local second = tonumber(string.sub(isoDate, 18, 19))
  if not second then error("Can't convert second to number") end

  local timezoneHour, timezoneMinute
  if dateLen >= 22 then
    timezoneHour = tonumber(string.sub(isoDate, 12, 13))
    if not timezoneHour then error("Can't convert time zone hour to number") end
  else
    timezoneHour = 0
  end
  if dateLen >= 25 then
    timezoneMinute = tonumber(string.sub(isoDate, 12, 13))
    if not timezoneMinute then error("Can't convert time zone minute to number") end
  else
    timezoneMinute = 0
  end

  return {
    year = year, month = month, day = day, hours = hours, minute = minute, second = second,
    timezoneHour = timezoneHour, timezoneMinute = timezoneMinute,
  }
end

--- Clones the object in a custom way.
-- If the object is a table and for all its table fields recursively, it does a deep
-- clone. For all non-table fields recursively, or if the object is not a table, it
-- does a shallow clone.
-- There are two aspects this function does not handle:
-- * metatables
-- * recursive tables.
-- @param obj any The object to be cloned
-- @return any The cloned object
local function cloneTablesDeepOthersShallow(obj)
  if type(obj) ~= 'table' then return obj end

  local res = {}
  for k, v in pairs(obj) do
    res[cloneTablesDeepOthersShallow(k)] = cloneTablesDeepOthersShallow(v)
  end
  return res
end

--- Shows the status of the fiscal printer.
-- @tparam string msg message to be shown as status
-- @tparam number subNumber the ID of the view where the status is shown
local function showFiscalPrinterStatus(msg, subNumber)
  local wndSubNum = subNumber or 69
  local gestoInfo = vpos.view.LayoutWindow(wndSubNum)
  gestoInfo:setText(msg)
end

---Determines if a string is nil or empty, or contains only whitespaces.
---@param str any The string
---@return boolean `true` if the string is nil or empty or only whitespaces, otherwise `false`
local function isNilOrWhitespaceString(str)
  return str == nil or #string.gsub(str, "^%s*(.-)%s*$", "%1") == 0
end


--*************************************************************
--- Metadata functions
-- @section Metadata functions

--- Reads the queue from the script metadata, indexed by "key" key.
-- @treturn table|nil The metadata queue indexed by "key" if present, otherwise `nil`
function readMD()
  local metaTab = vpos.script.currentScript():getMetaData()
  if not metaTab or not next(metaTab) then
    return nil
  else
    return metaTab.key
  end
end

--- Writes the queue to the script metadata, indexed by the given key.
-- @tparam table q The queue
-- @tparam[opt] string key The key at which the queue is indexed in the metadata
function writeMD(q, key)
  if not q or not next(q) then return end
  key = key or "key"
  local metaTab = {key = q}
  return vpos.script.currentScript():setMetaData(metaTab)
end

--- Clears the script metadata.
-- Practically, erases the log queue and saves this empty queue to the metadata.
function clearMD()
  eraseQueue(logList)
  writeMD(logList)
end


--*************************************************************
--- Queue functions
-- @section Queue functions

--- Gets the queue size.
-- @tparam table q The queue
-- @treturn number The queue size
function queueSize(q)
  return math.abs(q.first) - math.abs(q.last) + 1
end

--- Checks if the queue is empty.
-- @tparam table q The queue
-- @treturn boolean `true` if the queue is empty, otherwise `false`
function isQueueEmpty(q)
  if not q.first or not q.last then return true end
  if q.first > q.last then return true else return false end
end

--- Erases all elements from the queue.
-- @tparam table q The queue
function eraseQueue(q)
  for i in pairs(q) do
    q[i] = nil
  end
  q.first = 0
  q.last = -1
end

--- Dumps the queue to file.
-- @tparam table q The queue
function dumpQueue(q)
  -- dump all to file logger.log
  local f = getLogFile("logger.vsp", 500)
  local message = ""
  local size = 0
  local count = 0
  q.first = nil
  q.last = nil
  for k,v in pairs(q) do
      message = message .. v.scriptName .. " " .. v.datetime .. " " .. v.message .. "\n"
      size = size + #message
      if size > 5000 then
        f.fh:write(message)
        f.fh:flush()
        count = count + size
        message = ""
        size = 0
      end
  end
  f.fh:close()

  return count
end

--- Gets the initial queue.
-- Gets the queue saved in the script metadata if present, otherwise an empty and
-- initialized queue.
-- @treturn table The inital queue
-- @see readMD
-- @see isQueueEmpty
function getInitialQueue()
  local ok, initMetaData = pcall(readMD)
  assert(ok, initMetaData)
  if ok and initMetaData and not isQueueEmpty(initMetaData) then
    return initMetaData
  else
    return {first = 0, last = -1}
  end
end

---
-- Get the element from the head of the queue.
-- This function is used to completely remove the element
-- or reuse it to enqueue.
-- @tparam table queue
-- @tparam boolean use
-- @treturn table when use is true
function dropHeadElem(q, use)
  local last = q.last
  local unfit = q[last]
  q[last] = nil
  q.last = last - 1
  if use then return unfit end
end

---
-- Enqueue.
-- @tparam table queue
-- @tparam table value
function ListPushLeft(value)
  if not value then return end
  local first = (logList and logList.first or 0) - 1
  value.datetime = value.datetime or dateISO()
  value.priority = value.priority or "22"
  logList.first = first
  logList[first] = cloneTablesDeepOthersShallow(value)
  -- save the new queue to metadata
  writeMD(logList)
end

---
-- Get(read) the element from the head of the list.
-- @tparam table queue
-- @treturn table
-- @treturn table
function ListGetRight(q)
  local last = q.last
  return q[last]
end

---
-- Dequeue.
-- @tparam table queue
function ListPopRight(q)
  local last = q.last
  q[last] = nil
  q.last = last - 1
end

---
-- Send the logs and update the queue and metadata
-- @tparam table logList table containing the logs
function sendFromQueue(q)
  local ok, message = pcall(ListGetRight, q)
  assert(ok, message)
  message.qLast = q.last
  message.qFirst = q.first
  if ok then
    local ok, err = pcall(sendMessage, message)
    assert(ok, err)
    if ok then
      local ok, err = pcall(ListPopRight, q)
      assert(ok, err)
      if ok then
        writeMD(q)
      else
        ListPushLeft({scriptName="logger.vsp",
              url=URL_PAPERTRAIL,
              logType="online",
              logSize=300,
              priority="11",
              messageLevel=logLevel.Error,
              message= err})
      end
    else
      ListPushLeft({scriptName="logger.vsp",
              url=URL_PAPERTRAIL,
              logType="online",
              logSize=300,
              priority="11",
              messageLevel=logLevel.Error,
              message= err})
    end
  end
end

---
-- Manage the queue
-- @tparam table logList table containing the logs
function handleQueue(q)
  if not isQueueEmpty(q) then
    local qSize = queueSize(q)
    --showStatus("Q:"..tostring(qSize))
    if qSize > 150 then
      local ok, resp = pcall(dumpQueue, q)
      assert(ok, resp)
      --initialse empty queue
      eraseQueue(q)

      ListPushLeft({scriptName="logger.vsp",
              url=URL_PAPERTRAIL,
              logType="online",
              logSize=300,
              priority="11",
              messageLevel=logLevel.Error,
              message= "QUEUE WAS ERASED:"..tostring(resp)})
      local resp2
      ok, resp2 = pcall(writeMD, q)
      assert(ok, resp2)
    else
      local limit
      if qSize > 10 then limit = 10 else limit = qSize end
      for i=1,limit do

        local ok, resp = pcall(sendFromQueue, q)
        assert(ok, resp)
        if not ok then
          ListPushLeft({scriptName="logger.vsp",
                url=URL_PAPERTRAIL,
                logType="online",
                logSize=300,
                priority="11",
                messageLevel=logLevel.Error,
                message= resp})
        end
      end
    end
  end
end


--**************************************************************
--- File functions
-- @section File functions

---Gets the base file name, namely the file name without the extension, from the file path.
---@param filePath string? The file path
---@return string? # The base file name on successful extraction, otherwise `nil`.
local function get_base_file_name(filePath)
  if not filePath then return nil end

  --local _, _, _*, fileBaseName = string.find(scriptName, "^%a*:?[/\\]?([^/\\][/\\])*(.+)%.%a+$")

  local i, j = filePath:find(':', 1, true)
  if i then filePath = filePath:sub(j + 1) end

  -- determine the last directory separator in the reversed path
  local reversedPath = filePath:reverse()
  i, j = reversedPath:find("/", 1, true)
  local i2, j2 = reversedPath:find("\\", 1, true)
  local minI
  if i and i2 then
    if i < i2 then minI = i else minI = i2 end
  elseif i then
    minI = i
  elseif i2 then
    minI = i2
  end

  -- get the normal and reversed file names
  local fileName, reversedName
  if minI then -- we have a directory path
    fileName = filePath:sub(-minI + 1)
    reversedName = reversedPath:sub(1, minI - 1)
  else
    fileName = filePath
    reversedName = reversedPath
  end

  -- extract the base file name
  i, j = reversedName:find(".", 1, true)
  if i then
    return fileName:sub(1, -i - 1)
  else
    return fileName
  end
end

--- Checks for the existance of the file.
-- @tparam string fn File name/path to be checked
-- @treturn boolean `true` if the file exists, otherwise `false`
function file_exists(fn, host)
  if not fn then return false end
  allowedHosts = {["VPOS"] = 1, ["FILE"] = 1, ["MEDIAFILE"] = 1}

  local i, j = string.find(fn, ":")
  local fileHost
  if i then
    fileHost = fn:sub(1, j-1)
    fn = fn:gsub("VPOS:", "")
    fn = fn:gsub("FILE:", "")
  end

  host = host or fileHost or "VPOS"
  if not allowedHosts[host] then return false end

  local scripts = vpos.file.getFileList(host)
  for _,s in pairs(scripts) do
    if fn == s then
      return true
    end
  end
  return false
end

---
-- Function that moves/renames a file
-- @tparam string fn1 source filename
-- @tparam string fn2 destination filename
-- @tparam boolean overwrite flag to overwrite existing destination file
function file_rename(fn1, fn2, overwrite)
  if not file_exists(fn1) then return false, string.format("Source file '%s' is missing!", fn1 or "") end
  if file_exists(fn2) and not overwrite then return false, string.format("Destination file '%s' already exists!", fn2) end

  ok, err = vpos.renameFile(fn1, fn2)
  -- if the error is DestinationFileExists and we have to overwrite
  if not ok and err == 1 and overwrite then
    ok, err = vpos.file.delete(fn2)
    ok, err = vpos.renameFile(fn1, fn2)
    return ok, err
  end
  return ok, err
end

---
-- Function which creates a log file having the name of the script and extension ".log"
-- @tparam string scriptName name of the script
-- @treturn table containing the file handler and a function to get the updated log size
function getLogFile(scriptName, logSizeInKB)
  local fileSize = logSizeInKB or 300
  local _,_, scriptFileName, scriptFileExtension = string.find(scriptName, "(.+)%.(%a+)")
  local fileName = tostring(scriptFileName or "log") .. ".log"
  local logSize = function()
                    if vpos.script.Script(fileName) then
                      return tonumber(vpos.script.Script(fileName):getSize())/1000 or 0
                    else
                      return 0
                    end
                  end
  if logSize() < fileSize then
    fh, errMsg = io.open("VPOS:"..fileName, "a+")
    assert(fh, errMsg)
  else
    local backupFile = fileName:sub(1, -5) .. ".1.log"
    ok, err, e = pcall(file_rename, "VPOS:"..fileName, "VPOS:"..backupFile, true)
    assert(ok, err)
    if not err then ok, err = vpos.file.delete("VPOS:"..fileName) end
    fh, errMsg = io.open("VPOS:"..fileName, "w")
    assert(fh, errMsg)
  end

  if not fh then
    local backupFile = fileName:sub(1, -5) .. ".1.log"
    ok, err, e = pcall(file_rename, "VPOS:"..fileName, "VPOS:"..backupFile, true)
    assert(ok, err)
    if not err then ok, err = vpos.file.delete("VPOS:"..fileName) end
    fh, errMsg = io.open("VPOS:"..fileName, "w")
    assert(fh, errMsg)
  end

  return {fh = fh, size = logSize, scriptFileName = scriptFileName}
end


--**************************************************************
--- Message functions
-- @section Message functions

local function mapMessageLevelToPriority(messageLevel)
  if not messageLevel then                 assert(false, "Nil message level");  return 14
  elseif messageLevel == logLevel.Trace or messageLevel == logLevel.Debug then  return 15
  elseif messageLevel == logLevel.Info then                                     return 14
  elseif messageLevel == logLevel.Dev then                                      return 13
  elseif messageLevel == logLevel.Warn then                                     return 12
  elseif messageLevel == logLevel.Error then                                    return 11
  else                            assert(false, "Unrecognized message level");  return 14 end
end

---Decomposes/Unformats an offline message string/line into its parts.<br/>
---Raises an error if a message part can't be determined or converted.
---@param str string The message string/line
---@return table  A table with all of the message string parts:
---  * `sendingIsoDate` string: should be in ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`
---  * `messageLevel` string: the log level
---  * `qFirst`, `qLast` integer: the original queue boundary indexes
---  * `messageBody` string: the actual message;
local function decomposeOfflineMessageString(str)
  assert(str)

  local k = 1;
  local i, j = string.find(str, " [", k, true)
  if not i or i <= 1 then error("Can't determine send date") end
  local sendingIsoDate = string.sub(str, k, i - 1)

  k = j + 1
  i, j = string.find(str, "] >> ", k, true)
  if not i or i <= 1 then error("Can't determine log level") end
  local messageLevel = string.sub(str, k, i - 1)

  k = j + 1
  i, j = string.find(str, ":", k, true)
  if not i or i <= 1 then error("Can't determine queue first index") end
  local qFirst = tonumber(string.sub(str, k, i - 1))
  if qFirst == nil then error("Can't convert queue first index to number") end

  k = j + 1
  i, j = string.find(str, " ", k, true)
  if not i or i <= 1 then error("Can't determine queue last index") end
  local qLast = tonumber(string.sub(str, k, i - 1))
  if qLast == nil then error("Can't convert queue last index to number") end

  k = j + 1
  local messageBody = string.sub(str, k)

  return {
    sendingIsoDate = sendingIsoDate, messageLevel = messageLevel,
    qFirst = qFirst, qLast = qLast, messageBody = messageBody,
  }
end

--- Formats the message by adding information about the script and POS terminal.
--- @param message table Message containing the needed information
--- @param fallback boolean `true` if called due to fallback
--- @return string outStr Log message to send
function formatMessage(message, fallback)
  local outStr = ""

  if message.logType == "online" and not fallback then
    local scriptVersion = tostring(vpos.tables.Table(806):getData(message.scriptName, 15) or 0)
    local scriptData = string.format("%s_v:%s", message.scriptName, scriptVersion)
    local trace = (message.messageLevel == "trace" and "[trace] ") or ""

    outStr = "<" .. message.priority .. ">1 " .. message.datetime .. " " .. COMP_NAME .. POS_NAME ..
             " " .. scriptData .. " - - - " .. trace ..
             message.qFirst .. ":" .. message.qLast .. " " .. message.message .. "\n"
  else
    outStr = message.datetime .. " [" .. message.messageLevel .. "] >> " ..
             message.qFirst .. ":" .. message.qLast .. " " .. message.message .. "\n"
  end

  return outStr
end

--- Sends the message to be logged.
-- Sends the message using sockets over the internet (online mode). If this fails
-- or is explicitly requested, writes the message to a file (offline mode).
-- @tparam table message Message containing the information to be logged
function sendMessage(message)
  local ok, outStr = pcall(formatMessage, message)
  assert(ok, outStr)
  local _,_, scriptFN = string.find(message.scriptName, "(.+)%.(%a+)")

  if not ok then
    outStr = "<11>1 " .. dateISO() .. " " .. COMP_NAME .. POS_NAME ..
             " logger.vsp - - - ________PCALL error:" .. tostring(outStr) .. "\n"
  end

  if message.logType == "online" and message.url then
    logURL = message.url
    logURL = logURL:gsub("http://", "")
    _, _, logURL, logPORT = logURL:find("(.-):(%d+)")
    -- retry to create the socket only after several logs were locally written
    if (not socket and (offlineCounter == 0 or offlineCounter >= 9)) or offlineCounter >= 9 then
      socket = vpos.communication.Socket(logURL, logPORT, 3000)
      offlineCounter = 0
    end

    local sent = socket and socket:write(outStr)
    if not sent then
      offlineCounter = offlineCounter + 1

      -- fallback to file
      ok, outStr = pcall(formatMessage, message, true)
      assert(ok, outStr)
      if not file or file.size() >= message.logSize or scriptFN ~= file.scriptFileName then
        file = getLogFile(message.scriptName, message.logSize)
      end
      file.fh:write(outStr)
      file.fh:flush()
    end
  else
    -- fallback to file
    if not file or file.size() >= message.logSize or scriptFN ~= file.scriptFileName then
      file = getLogFile(message.scriptName, message.logSize)
    end
    file.fh:write(outStr)
    file.fh:flush()
  end
end


--*************************************************************
--- Upload offline logs functions
-- @section Upload offline logs functions

local function isUploadRound()
  local split = UploadStopWatch:split()
  if split < UPLOAD_ROUND_INTERVAL then
     return false
  else
     return true
  end
end

local function resetUploadWatch() UploadStopWatch:reset() end

local function areUploadConditionsMet()
  -- @todo implement!
  return true
end

local function updateLogFileList()
  local fileList = vpos.file.getFileList("VPOS")

  -- clear log file elements for files deleted in the mean time
  for fileName, _ in pairs(LogFileList) do
    if not fileList[fileName] then LogFileList[fileName] = nil end
  end

  -- add new log file elements and update the fileSize for the existing ones
  for fileName, _ in pairs(fileList) do
    if string.find(fileName, ".log") then
      local scLog = vpos.script.Script {scriptURL = "VPOS:" .. fileName}
      if not LogFileList[fileName] then
        LogFileList[fileName] = {readOffset = 0, uploadCounter = 0}
      end
      LogFileList[fileName].fileSize = scLog:getSize()
    end
  end
end

local function deleteLogFileAndFileElement(fileName)
  assert(fileName)

  -- delete the log file
  local ok = vpos.file.delete("VPOS:" .. fileName)
  assert(ok)

  -- delete the log file element
  assert(LogFileList[fileName])
  LogFileList[fileName] = nil
end

local function deleteEmptyLogFilesAndFileElements()
  for fileName, fileElem in pairs(LogFileList) do
    if fileElem.fileSize <= 0 then deleteLogFileAndFileElement(fileName) end
  end
end

local function determineLogFileToUpload()
  local fileNameToUpload = nil
  local minCounter = math.maxinteger

  -- get the first log file element with the minimum upload counter  
  for fileName, fileElem in pairs(LogFileList) do
    assert(fileElem.uploadCounter)
    if fileElem.uploadCounter <= minCounter then
      fileNameToUpload = fileName
      minCounter = fileElem.uploadCounter
    end
  end

  return fileNameToUpload
end

---
---@param sendingIsoDate string The sending ISO date of a log file line / message string
---@return boolean # `true` if the log file line / message string is recent enough to be uploaded; otherwise `false`
local function isRecentLogFileLine(sendingIsoDate)
  assert(sendingIsoDate)
  local ok, decomposedDate = pcall(decomposeISODate, sendingIsoDate)
  -- we'll consider the log line as being recent upon encountering exceptions
  if not ok then
    assert(false, decomposedDate) --- @todo log dev
    return true
  end

  -- compare the dates:

  local date = vpos.datetime.DateTime()

  date:add(vpos.datetime.DateField.Day, -UPLOAD_LOG_LINE_AGE_IN_DAYS);
  local refUnixTime = date:getUnixTime()

  date:setDate(decomposedDate.day, decomposedDate.month, decomposedDate.year)
  date:setTime(decomposedDate.hour, decomposedDate.minute, decomposedDate.second)

  return date:getUnixTime() >= refUnixTime
end

local function uploadRecentLogFileLine(fileName, line)
  assert(fileName and line)

  local ok, decomposedMsg = pcall(decomposeOfflineMessageString, line)
  -- we'll consider the log line as being recent upon encountering exceptions
  if not ok then
    -- BETTER don't log dev here, b/c the log file might have a different syntax
     assert(false, decomposedMsg)

     ListPushLeft({
      datetime     = dateISO(),
      scriptName   = assert(get_base_file_name(fileName)) .. ".vsp",
      url          = URL_PAPERTRAIL,
      logType      = "online",
      logSize      = 300,
      priority     = mapMessageLevelToPriority(logLevel.Info),
      messageLevel = logLevel.Info,
      message      = line,
    })
    return true
  else
    if isNilOrWhitespaceString(decomposedMsg.messageBody) then return false end
    if not isRecentLogFileLine(decomposedMsg.sendingIsoDate) then return false end

    --TODO the real script name needs to be known, which may have the *.vsc extension !?
    ListPushLeft({
      datetime     = decomposedMsg.sendingIsoDate,
      scriptName   = assert(get_base_file_name(fileName)) .. ".vsp",
      url          = URL_PAPERTRAIL,
      logType      = "online",
      logSize      = 300,
      priority     = mapMessageLevelToPriority(decomposedMsg.messageLevel),
      messageLevel = decomposedMsg.messageLevel,
      message      = decomposedMsg.messageBody,
    })
  end
end

local function uploadChunkOfLogFileLines(fileName)
  assert(fileName)
  local fileElem = LogFileList[fileName];
  assert(fileElem)

  local uploadedSize = 0
  local processedSize = 0

  --TODO SHOULD it be "rb"?
  local fileHandle, errMsg = io.open("VPOS:" .. fileName, "r") -- open log file
  if not fileHandle then
    --TODO add: logDev("Can't open file 'VPOS:" .. filename .. "'", errMsg)
    return uploadedSize
  end
  assert(fileHandle)

  _, errMsg = fileHandle:seek("set", fileElem.readOffset)
  if errMsg then
    --TODO add: logDev("Can't seek in file 'VPOS:" .. filename .. "' at pos " .. tostring(fileElem.readOffset), errMsg)
    return uploadedSize
  end

  while uploadedSize < LOG_CHUNK_SIZE_TO_UPLOAD do
    local line = fileHandle:read("L")
    if not line then break end

    local lineLen = string.len(line)
    processedSize = processedSize + lineLen
    --TODO Trim end CR-LF from line ?

    if uploadRecentLogFileLine(fileName, line) then
      uploadedSize = uploadedSize + lineLen
    end
  end

  fileHandle:close()
  return processedSize
end

local function updateLogFileElement(fileName, processedSize)
  assert(fileName)
  local fileElem = LogFileList[fileName];
  assert(fileElem)

  -- update the read position for the next chunk upload from this log file
  assert(fileElem.readOffset)
  fileElem.readOffset = fileElem.readOffset + processedSize

  -- increment the upload counter
  assert(fileElem.uploadCounter)
  fileElem.uploadCounter = fileElem.uploadCounter + 1
end

local function deleteFullyProcessedLogFileAndFileElement(fileName)
  assert(fileName)
  local fileElem = LogFileList[fileName];
  assert(fileElem)

  assert(fileElem.readOffset and fileElem.fileSize)
  if fileElem.readOffset >= fileElem.fileSize then deleteLogFileAndFileElement(fileName) end
end

function uploadOfflineLogs()
  -- @todo Add offline setting check
  if not isUploadRound() then return end
  if not areUploadConditionsMet() then resetUploadWatch() return end

  updateLogFileList()
  deleteEmptyLogFilesAndFileElements()

  local fileName, fileElem = determineLogFileToUpload()
  if fileName ~= nil and fileElem ~= nil then
    local processedSize = uploadChunkOfLogFileLines(fileName)
    updateLogFileElement(fileName, processedSize)
    deleteFullyProcessedLogFileAndFileElement(fileName)
  end

  resetUploadWatch()
end


--*************************************************************
--- Timer functions
-- @section Timer functions

--- Function called on timer timeouts.
-- Timer function calling `handleQueue` and `uploadOfflineLogs` for sending
-- the logs to papertrail.
function onLogTimer()
  local ok, err = pcall(handleQueue, logList)
  assert(ok, err)
  ok, err = pcall(uploadOfflineLogs, logList)
  assert(ok, err)
end


--*************************************************************
--- Initialization functions
-- @section Top functions

local function initSettings()
    -- format the company name
    COMP_NAME = string.lower(vpos.systeminfo.Company():getName())
    COMP_NAME = COMP_NAME:gsub("sc", ""):gsub(" ", "")
    COMP_NAME = COMP_NAME:sub(1, 4) .. "_"
    POS_NAME = tostring(vpos.getSystemInfo(vpos.SystemInfo.ECRId):gsub(" ", ""))
end

local function initLogList()
  local ok
  ok, logList = pcall(getInitialQueue)
  assert(ok, logList)
  if not ok then
    ok, logList = pcall(getInitialQueue)
    assert(ok, logList)
    writeMD()
  end
end

local function initTimers()
  vpos.events.registerTimerFunction("onLogTimer", LOG_TIMER_INTERVAL)
  UploadStopWatch:start()
end


--*************************************************************
--- Main
-- @section main

initSettings()
initLogList()

vpos.script.registerAsInterScript()

initTimers()

---
-- @entrypoint ClearMetadata
vpos.events.registerEntryPointFunction(99, "clearMD")
