--!ScriptAPI: 1.14
--!ScriptVersion: 1.8
-- Script name: logger.vsp
-- Author: Vlad Isac
-- Date: 03/2020
-- Description: use metadata and queue for sending log messages to url (eg http://logs6.papertrailapp.com:17732 )


--*************************************************************
--- Global private settings (read-only initialized variables used as constants)
-- @section Global private settings

--- Company name
COMP_NAME = ""
--- POS name
POSNAME = ""

--- Interval in milliseconds, at which the script timer fires events for logging.
LOG_TIMER_INTERVAL = 300
--- Interval in milliseconds, at which a new round of uploading offline logs is started.
UPLOAD_ROUND_INTERVAL = 300000 -- 5 * 60 * 1000 [ms] = 5 [minutes]


--*************************************************************
--- Global private variables
-- @section Global private variables

assert = function(...) end

--- The logging list/queue containing all current messages to be logged.
logList = {}

--- Count the number of logging fallbacks to file.
-- @global offlineCounter
offlineCounter = 0

--- Table containing information on offline saved logs, for uploading them.
-- @global LogFileList
LogFileList = {}
--- Stop watch for uploading offline saved logs.
-- @global UploadStopWatch
UploadStopWatch = vpos.datetime.StopWatch()


--*************************************************************
--- Helper functions
-- @section Helper functions

--- Formats the given or current date as per ISO 8601 format.
-- Formats the given or the current date according to the ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`.
-- Length of returned date: currently, only the first 19 of the 25 characters are returned.
-- Example of returned date: `2016-11-09T04:25:28` (the full date would be `2016-11-09T04:25:28+01:00`).
-- @tparam[opt] date DateTime Date to be formatted; if nil, the current date is used
-- @treturn string Date formatted as per ISO 8601 format `yyyy-mm-ddThh:mm:ss±hh:mm`
local function dateISO(date)
  local date = date or vpos.datetime.DateTime()
  local day, month, year = date:getDate()
  local hour, minute, second = date:getTime()

  return tostring(year) .. "-" .. string.format("%02d", month) .. "-" .. string.format("%02d", day) .. "T" ..
         string.format("%02d", hour) .. ":" .. string.format("%02d", minute) .. ":" .. string.format("%02d", second)
end

--- Clones the object in a custom way.
-- If the object is a table and for all its table fields recursively, it does a deep
-- clone. For all non-table fields recursively, or if the object is not a table, it
-- does a shallow clone.
-- There are two aspects this function does not handle:
-- * metatables
-- * recursive tables.
-- @param obj any The object to be cloned
-- @return any The cloned object
local function cloneTablesDeepOthersShallow(obj)
  if type(obj) ~= 'table' then return obj end

  local res = {}
  for k, v in pairs(obj) do
    res[cloneTablesDeepOthersShallow(k)] = cloneTablesDeepOthersShallow(v)
  end
  return res
end

--- Shows the status of the fiscal printer.
-- @tparam string msg message to be shown as status
-- @tparam number subNumber the ID of the view where the status is shown
local function showFiscalPrinterStatus(msg, subNumber)
  local wndSubNum = subNumber or 69
  local gestoInfo = vpos.view.LayoutWindow(wndSubNum)
  gestoInfo:setText(msg)
end


--*************************************************************
--- Metadata functions
-- @section Metadata functions

--- Reads the queue from the script metadata, indexed by "key" key.
-- @treturn table|nil The metadata queue indexed by "key" if present, otherwise `nil`
function readMD()
  local metaTab = vpos.script.currentScript():getMetaData()
  if not metaTab or not next(metaTab) then
    return nil
  else
    return metaTab.key
  end
end

--- Writes the queue to the script metadata, indexed by the given key.
-- @tparam table q The queue
-- @tparam[opt] string key The key at which the queue is indexed in the metadata
function writeMD(q, key)
  if not q or not next(q) then return end
  key = key or "key"
  local metaTab = {key = q}
  return vpos.script.currentScript():setMetaData(metaTab)
end

--- Clears the script metadata.
-- Practically, erases the log queue and saves this empty queue to the metadata.
function clearMD()
  eraseQueue(logList)
  writeMD(logList)
end


--*************************************************************
--- Queue functions
-- @section Queue functions

--- Gets the queue size.
-- @tparam table q The queue
-- @treturn number The queue size
function queueSize(q)
  return math.abs(q.first) - math.abs(q.last) + 1
end

--- Checks if the queue is empty.
-- @tparam table q The queue
-- @treturn boolean `true` if the queue is empty, otherwise `false`
function isQueueEmpty(q)
  if not q.first or not q.last then return true end
  if q.first > q.last then return true else return false end
end

--- Erases all elements from the queue.
-- @tparam table q The queue
function eraseQueue(q)
  for i in pairs(q) do
    q[i] = nil
  end
  q.first = 0
  q.last = -1
end

--- Dumps the queue to file.
-- @tparam table q The queue
function dumpQueue(q)
  -- dump all to file logger.log
  local f = getLogFile("logger.vsp", 500)
  local message = ""
  local size = 0
  local count = 0
  q.first = nil
  q.last = nil
  for k,v in pairs(q) do
      message = message..v.scriptName.." " .. v.datetime .. " " .. v.message .. "\n"
      size = size + #message
      if size > 5000 then
        f.fh:write(message)
        f.fh:flush()
        count = count + size
        message = ""
        size = 0
      end
  end
  f.fh:close()

  return count
end

--- Gets the initial queue.
-- Gets the queue saved in the script metadata if present, otherwise an empty and
-- initialized queue.
-- @treturn table The inital queue
-- @see readMD
-- @see isQueueEmpty
function getInitialQueue()
  local ok, initMetaData = pcall(readMD)
  assert(ok, initMetaData)
  if ok and initMetaData and not isQueueEmpty(initMetaData) then
    return initMetaData
  else
    return {first = 0, last = -1}
  end
end

---
-- Get the element from the head of the queue.
-- This function is used to completely remove the element
-- or reuse it to enqueue.
-- @tparam table queue
-- @tparam boolean use
-- @treturn table when use is true
function dropHeadElem(q, use)
  local last = q.last
  local unfit = q[last]
  q[last] = nil
  q.last = last - 1
  if use then return unfit end
end

---
-- Enqueue.
-- @tparam table queue
-- @tparam table value
function ListPushLeft(value)
  if not value then return end
  local first = (logList and logList.first or 0) - 1
  value.datetime = value.datetime or dateISO()
  value.priority = value.priority or "22"
  logList.first = first
  logList[first] = cloneTablesDeepOthersShallow(value)
  -- save the new queue to metadata
  writeMD(logList)
end

---
-- Get(read) the element from the head of the list.
-- @tparam table queue
-- @treturn table
-- @treturn table
function ListGetRight(q)
  local last = q.last
  return q[last]
end

---
-- Dequeue.
-- @tparam table queue
function ListPopRight(q)
  local last = q.last
  q[last] = nil
  q.last = last - 1
end

---
-- Send the logs and update the queue and metadata
-- @tparam table logList table containing the logs
function sendFromQueue(q)
  local ok, message = pcall(ListGetRight, q)
  assert(ok, message)
  message.qLast = q.last
  message.qFirst = q.first
  if ok then
    local ok, err = pcall(sendMessage, message)
    assert(ok, err)
    if ok then
      local ok, err = pcall(ListPopRight, q)
      assert(ok, err)
      if ok then
        writeMD(q)
      else
        ListPushLeft({scriptName="logger.vsp",
              url="logs6.papertrailapp.com:17732",
              logType="online",
              logSize=300,
              priority="11",
              messageLevel="error",
              message= err})
      end
    else
      ListPushLeft({scriptName="logger.vsp",
              url="logs6.papertrailapp.com:17732",
              logType="online",
              logSize=300,
              priority="11",
              messageLevel="error",
              message= err})
    end
  end
end

---
-- Manage the queue
-- @tparam table logList table containing the logs
function handleQueue(q)
  if not isQueueEmpty(q) then
    local qSize = queueSize(q)
    --showStatus("Q:"..tostring(qSize))
    if qSize > 150 then
      local ok, resp = pcall(dumpQueue, q)
      assert(ok, resp)
      --initialse empty queue
      eraseQueue(q)

      ListPushLeft({scriptName="logger.vsp",
              url="logs6.papertrailapp.com:17732",
              logType="online",
              logSize=300,
              priority="11",
              messageLevel="error",
              message= "QUEUE WAS ERASED:"..tostring(resp)})
      local resp2
      ok, resp2 = pcall(writeMD, q)
      assert(ok, resp2)
    else
      local limit
      if qSize > 10 then limit = 10 else limit = qSize end
      for i=1,limit do

        local ok, resp = pcall(sendFromQueue, q)
        assert(ok, resp)
        if not ok then
          ListPushLeft({scriptName="logger.vsp",
                url="logs6.papertrailapp.com:17732",
                logType="online",
                logSize=300,
                priority="11",
                messageLevel="error",
                message= resp})
        end
      end
    end
  end
end


--**************************************************************
--- File functions
-- @section File functions

--- Checks for the existance of the file.
-- @tparam string fn File name/path to be checked
-- @treturn boolean `true` if the file exists, otherwise `false`
function file_exists(fn, host)
  if not fn then return false end
  allowedHosts = {["VPOS"] = 1, ["FILE"] = 1, ["MEDIAFILE"] = 1}

  local i, j = string.find(fn, ":")
  local fileHost
  if i then
    fileHost = fn:sub(1, j-1)
    fn = fn:gsub("VPOS:", "")
    fn = fn:gsub("FILE:", "")
  end

  host = host or fileHost or "VPOS"
  if not allowedHosts[host] then return false end

  local scripts = vpos.file.getFileList(host)
  for _,s in pairs(scripts) do
    if fn == s then
      return true
    end
  end
  return false
end

---
-- Function that moves/renames a file
-- @tparam string fn1 source filename
-- @tparam string fn2 destination filename
-- @tparam boolean overwrite flag to overwrite existing destination file
function file_rename(fn1, fn2, overwrite)

  if not file_exists(fn1) then return nil, string.format("Source file %s is missing!", fn1) end
  if file_exists(fn2) and not overwrite then return nil, string.format("Destination file %s already exists!", fn2) end

  ok, err = vpos.renameFile(fn1, fn2)
  -- if the error is DestinationFileExists and we have to overwrite
  if not ok and err == 1 and overwrite then
    ok, err = vpos.file.delete(fn2)
    ok, err = vpos.renameFile(fn1, fn2)
    return ok, err
  end
  return ok, err
end

---
-- Function which creates a log file having the name of the script and extension ".log"
-- @tparam string scriptName name of the script
-- @treturn table containing the file handler and a function to get the updated log size
function getLogFile(scriptName, logSizeInKB)
  local fileSize = logSizeInKB or 300
  local _,_, scriptFileName, scriptFileExtension = string.find(scriptName, "(.+)%.(%a+)")
  local fileName = tostring(scriptFileName or "log") .. ".log"
  local logSize = function()
                    if vpos.script.Script(fileName) then
                      return tonumber(vpos.script.Script(fileName):getSize())/1000 or 0
                    else
                      return 0
                    end
                  end
  if logSize() < fileSize then
    fh, errMsg = io.open("VPOS:"..fileName, "a+")
    assert(fh, errMsg)
  else
    local backupFile = fileName:sub(1, -5) .. ".1.log"
    ok, err, e = pcall(file_rename, "VPOS:"..fileName, "VPOS:"..backupFile, true)
    assert(ok, err)
    if not err then ok, err = vpos.file.delete("VPOS:"..fileName) end
    fh, errMsg = io.open("VPOS:"..fileName, "w")
    assert(fh, errMsg)
  end

  if not fh then
    local backupFile = fileName:sub(1, -5) .. ".1.log"
    ok, err, e = pcall(file_rename, "VPOS:"..fileName, "VPOS:"..backupFile, true)
    assert(ok, err)
    if not err then ok, err = vpos.file.delete("VPOS:"..fileName) end
    fh, errMsg = io.open("VPOS:"..fileName, "w")
    assert(fh, errMsg)
  end

  return {fh = fh, size = logSize, scriptFileName = scriptFileName}
end


--**************************************************************
--- Message functions
-- @section Message functions

---Format the message by adding information about the script and POS terminal.
-- @tparam table message containing the needed information
-- @tparam bool fallback true if called due to fallback
-- @treturn string outStr log message to send
function formatMessage(message, fallback)
  local outStr = ""

  if message.logType == "online" and not fallback then
    local scriptVersion = tostring(vpos.tables.Table(806):getData(message.scriptName, 15) or 0)
    local scriptData = string.format("%s_v:%s", message.scriptName, scriptVersion)
    local trace = (message.messageLevel == "trace" and "[trace] ") or ""

    outStr = "<" .. message.priority .. ">1 " .. message.datetime .. " " .. COMP_NAME .. POSNAME ..
             " " .. scriptData .. " - - - " .. trace ..
             message.qFirst .. ":" .. message.qLast .. " " .. message.message .. "\n"
  else
    outStr = message.datetime .. " [" .. message.messageLevel .. "] >> " ..
             message.qFirst .. ":" .. message.qLast .. " " .. message.message .. "\n"
  end

  return outStr
end

--- Sends the message to be logged.
-- Sends the message using sockets over the internet (online mode). If this fails
-- or is explicitly requested, writes the message to a file (offline mode).
-- @tparam table message Message containing the information to be logged
function sendMessage(message)
  local ok, outStr = pcall(formatMessage, message)
  assert(ok, outStr)
  local _,_, scriptFN = string.find(message.scriptName, "(.+)%.(%a+)")

  if not ok then
    outStr = "<11>1 " .. dateISO() .. " " .. COMP_NAME .. POSNAME ..
             " logger.vsp - - - ________PCALL error:" .. tostring(outStr) .. "\n"
  end

  if message.logType == "online" and message.url then
    logURL = message.url
    logURL = logURL:gsub("http://", "")
    _, _, logURL, logPORT = logURL:find("(.-):(%d+)")
    -- retry to create the socket only after several logs were locally written
    if (not socket and (offlineCounter == 0 or offlineCounter >= 9)) or offlineCounter >= 9 then
      socket = vpos.communication.Socket(logURL, logPORT, 3000)
      offlineCounter = 0
    end

    local sent = socket and socket:write(outStr)
    if not sent then
      offlineCounter = offlineCounter + 1

      -- fallback to file
      ok, outStr = pcall(formatMessage, message, true)
      assert(ok, outStr)
      if not file or file.size() >= message.logSize or scriptFN ~= file.scriptFileName then
        file = getLogFile(message.scriptName, message.logSize)
      end
      file.fh:write(outStr)
      file.fh:flush()
    end
  else
    -- fallback to file
    if not file or file.size() >= message.logSize or scriptFN ~= file.scriptFileName then
      file = getLogFile(message.scriptName, message.logSize)
    end
    file.fh:write(outStr)
    file.fh:flush()
  end

end


--*************************************************************
--- Upload offline logs functions
-- @section Upload offline logs functions

local function isUploadRound()
  local split = UploadStopWatch:split()
  if split < UPLOAD_ROUND_INTERVAL then
     return false
  else
     return true
  end
end

local function resetUploadWatch() UploadStopWatch:reset() end

local function areUploadConditionsMet()
  -- @todo implement!
  return true
end

local function updateLogFileList()
  local files = vpos.file.getFileList("VPOS")
  local logList = {}

  for k, fileName in pairs(files) do
    if string.find(fileName, ".log") then
      local scLog = vpos.script.Script {scriptURL = "VPOS:" .. fileName}
      if not LogFileList[fileName] then LogFileList[fileName] = {uploadCounter = 0} end
      LogFileList[fileName].fileSize = scLog:getSize()
    end
  end

  return logList
end

local function deleteEmptyLogFileAndFileEntry(fileName)
  assert(fileName, "Nil log file name")
  local fileEntry = LogFileList[fileName]
  if fileEntry.fileSize <= 0 then
    vpos.file.delete("VPOS:" .. fileName)
    LogFileList[fileName] = nil -- delete the log file entry
  end
end

local function deleteAllEmptyLogFilesAndFileEntries()
  for fileName, _ in pairs(LogFileList) do
    deleteEmptyLogFileAndFileEntry(fileName)
  end
end

local function determineLogFileToUpload()
  local fileNameToUpload = nil
  local fileEntryToUpload = {}
  local minCounter = math.maxinteger

  -- get the first log file entry with the minimum upload counter  
  for fileName, fileEntry in pairs(LogFileList) do
    if fileEntry.uploadCounter <= minCounter then
      fileNameToUpload = fileName
      fileEntryToUpload = fileEntry
      minCounter = fileEntry.uploadCounter
    end
  end

  return fileNameToUpload, fileEntryToUpload
end

local function uploadChunkOfLogFileLines(fileName, fileEntry)
  local chunkSize = 2^14 -- 16 KB

  --while read do
  --   
  --end

  return chunkSize
end

local function trimLogFileChunkFromStart(fileName, startSize)
  assert(fileName, "Nil log file name")
  local fileEntry = LogFileList[fileName]

end

local function updateLogFileUploadCounter(fileName)
  assert(fileName, "Nil log file name")
  local fileEntry = LogFileList[fileName];
  if fileEntry ~= nil then
    assert(fileEntry.uploadCounter, "No upload counter in log file entry '" .. fileName .. "'");
    fileEntry.uploadCounter = fileEntry.uploadCounter + 1
  end
end

function uploadOfflineLogs()
  if not isUploadRound() then return end
  if not areUploadConditionsMet() then resetUploadWatch() return end

  updateLogFileList()
  deleteAllEmptyLogFilesAndFileEntries()

  local fileName, fileEntry = determineLogFileToUpload()
  if fileName ~= nil and fileEntry ~= nil then
    local sentSize = uploadChunkOfLogFileLines(fileName, fileEntry)
    trimLogFileChunkFromStart(fileName, fileEntry, sentSize)
    updateLogFileUploadCounter(fileName)
    deleteEmptyLogFileAndFileEntry(fileName)
  end

  resetUploadWatch()
end


--*************************************************************
--- Timer functions
-- @section Timer functions

--- Function called on timer timeouts.
-- Timer function calling `handleQueue` and `uploadOfflineLogs` for sending
-- the logs to papertrail.
function onLogTimer()
  local ok, err = pcall(handleQueue, logList)
  assert(ok, err)
  local ok, err = pcall(uploadOfflineLogs, logList)
  assert(ok, err)
end


--*************************************************************
--- Initialization functions
-- @section Top functions

local function initSettings()
    -- format the company name
    COMP_NAME = string.lower(vpos.systeminfo.Company():getName())
    COMP_NAME = COMP_NAME:gsub("sc", ""):gsub(" ", "")
    COMP_NAME = COMP_NAME:sub(1, 4) .. "_"
    POSNAME = tostring(vpos.getSystemInfo(vpos.SystemInfo.ECRId):gsub(" ", ""))
end

local function initLogList()
  local ok
  ok, logList = pcall(getInitialQueue)
  assert(ok, logList)
  if not ok then
    ok, logList = pcall(getInitialQueue)
    assert(ok, logList)
    writeMD()
  end
end

local function initTimers()
  vpos.events.registerTimerFunction("onLogTimer", LOG_TIMER_INTERVAL)
  UploadStopWatch:start()
end


--*************************************************************
--- Main
-- @section main

initSettings()
initLogList()

vpos.script.registerAsInterScript()

initTimers()

---
-- @entrypoint ClearMetadata
vpos.events.registerEntryPointFunction(99, "clearMD")
